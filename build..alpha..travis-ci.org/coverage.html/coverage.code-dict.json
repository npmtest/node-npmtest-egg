{"/home/travis/build/npmtest/node-npmtest-egg/test.js":"/* istanbul instrument in package npmtest_egg */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-egg/lib.npmtest_egg.js":"/* istanbul instrument in package npmtest_egg */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_egg = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_egg = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-egg/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-egg && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_egg */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_egg\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_egg.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_egg.rollup.js'] =\n            local.assetsDict['/assets.npmtest_egg.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_egg.__dirname +\n                    '/lib.npmtest_egg.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/index.js":"'use strict';\n\n/**\n * @namespace Egg\n */\n\n/**\n * Start egg application with cluster mode\n * @since 1.0.0\n */\nexports.startCluster = require('egg-cluster').startCluster;\n\n/**\n * @member {Application} Egg#Application\n * @since 1.0.0\n */\nexports.Application = require('./lib/application');\n\n/**\n * @member {Agent} Egg#Agent\n * @since 1.0.0\n */\nexports.Agent = require('./lib/agent');\n\n/**\n * @member {AppWorkerLoader} Egg#AppWorkerLoader\n * @since 1.0.0\n */\nexports.AppWorkerLoader = require('./lib/loader').AppWorkerLoader;\n\n/**\n * @member {AgentWorkerLoader} Egg#AgentWorkerLoader\n * @since 1.0.0\n */\nexports.AgentWorkerLoader = require('./lib/loader').AgentWorkerLoader;\n\n/**\n * @member {Controller} Egg#Controller\n * @since 1.1.0\n */\nexports.Controller = require('egg-core').BaseContextClass;\n\n/**\n * @member {Service} Egg#Service\n * @since 1.1.0\n */\nexports.Service = require('egg-core').BaseContextClass;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-cluster/index.js":"'use strict';\n\nconst Master = require('./lib/master');\n\n/**\n * cluster start flow:\n *\n * [startCluster] -> master -> agent_worker -> new [Agent]       -> agentWorkerLoader\n *                         `-> app_worker   -> new [Application] -> appWorkerLoader\n *\n */\n\n/**\n * start egg app\n * @method Egg#startCluster\n * @param {Object} options {@link Master}\n * @param {Function} callback start success callback\n */\nexports.startCluster = function(options, callback) {\n  new Master(options).ready(callback);\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-cluster/lib/master.js":"'use strict';\n\nconst util = require('util');\nconst path = require('path');\nconst cluster = require('cluster');\nconst EventEmitter = require('events');\nconst childprocess = require('child_process');\nconst cfork = require('cfork');\nconst ready = require('get-ready');\nconst debug = require('debug')('egg-cluster');\nconst detectPort = require('detect-port');\nconst ConsoleLogger = require('egg-logger').EggConsoleLogger;\n\nconst parseOptions = require('./utils/options');\nconst Messenger = require('./utils/messenger');\n\nconst agentWorkerFile = path.join(__dirname, 'agent_worker.js');\nconst appWorkerFile = path.join(__dirname, 'app_worker.js');\n\nclass Master extends EventEmitter {\n\n  /**\n   * @constructor\n   * @param {Object} options\n   *  - {String} [framework] - specify framework that can be absolute path or npm package\n   *  - {String} [baseDir] directory of application, default to `process.cwd()`\n   *  - {Object} [plugins] - customized plugins, for unittest\n   *  - {Number} [workers] numbers of app workers, default to `os.cpus().length`\n   *  - {Number} [port] listening port, default to 7001(http) or 8443(https)\n   *  - {Boolean} [https] https or not\n   *  - {String} [key] ssl key\n   *  - {String} [cert] ssl cert\n   */\n  constructor(options) {\n    super();\n    this.options = parseOptions(options);\n    this.messenger = new Messenger(this);\n\n    ready.mixin(this);\n\n    this.isProduction = isProduction();\n    this.isDebug = isDebug();\n\n    // app started or not\n    this.isStarted = false;\n    this.logger = new ConsoleLogger({ level: 'INFO' });\n\n    // get the real framework info\n    const frameworkPath = this.options.framework;\n    const frameworkPkg = require(path.join(frameworkPath, 'package.json'));\n\n    this.logger.info(`[master] =================== ${frameworkPkg.name} start =====================`);\n    this.logger.info(`[master] ${frameworkPkg.name} version ${frameworkPkg.version}`);\n    this.logger.info('[master] start with options: %j', this.options);\n    this.logger.info(`[master] start with env: isProduction: ${this.isProduction}, isDebug: ${this.isDebug}, EGG_SERVER_ENV: ${process.env.EGG_SERVER_ENV}, NODE_ENV: ${process.env.NODE_ENV}`);\n\n    const startTime = Date.now();\n\n    this.ready(() => {\n      this.isStarted = true;\n      const stickyMsg = this.options.sticky ? ' with STICKY MODE!' : '';\n      this.logger.info('[master] %s started on %s://127.0.0.1:%s (%sms)%s',\n        frameworkPkg.name, this.options.https ? 'https' : 'http', this.options.port, Date.now() - startTime, stickyMsg);\n\n      const action = 'egg-ready';\n      this.messenger.send({ action, to: 'parent' });\n      this.messenger.send({ action, to: 'app', data: this.options });\n      this.messenger.send({ action, to: 'agent', data: this.options });\n    });\n\n    this.on('agent-exit', this.onAgentExit.bind(this));\n    this.on('agent-start', this.onAgentStart.bind(this));\n    this.on('app-exit', this.onAppExit.bind(this));\n    this.on('app-start', this.onAppStart.bind(this));\n    this.on('reload-worker', this.onReload.bind(this));\n\n    // fork app workers after agent started\n    this.once('agent-start', this.forkAppWorkers.bind(this));\n\n    this.onExit();\n\n    detectPort((err, port) => {\n      /* istanbul ignore if */\n      if (err) {\n        err.name = 'ClusterPortConflictError';\n        err.message = '[master] try get free port error, ' + err.message;\n        this.logger.error(err);\n        return;\n      }\n      this.options.clusterPort = port;\n      this.forkAgentWorker();\n    });\n  }\n\n  startMasterSocketServer(cb) {\n    // Create the outside facing server listening on our port.\n    require('net').createServer({ pauseOnConnect: true }, connection => {\n      // We received a connection and need to pass it to the appropriate\n      // worker. Get the worker for this connection's source IP and pass\n      // it the connection.\n      const worker = this.stickyWorker(connection.remoteAddress);\n      worker.send('sticky-session:connection', connection);\n    }).listen(this.options.port, cb);\n  }\n\n  stickyWorker(ip) {\n    const workerNumbers = this.options.workers;\n    const ws = Array.from(this.workers.keys());\n\n    let s = '';\n    for (let i = 0; i < ip.length; i++) {\n      if (!isNaN(ip[i])) {\n        s += ip[i];\n      }\n    }\n    s = Number(s);\n    const pid = ws[s % workerNumbers];\n    return this.workers.get(pid);\n  }\n\n  forkAgentWorker() {\n    this.agentStartTime = Date.now();\n\n    const args = [ JSON.stringify(this.options) ];\n    // debug port:\n    // agent_worker: 5856\n    // master: 5857\n    // app_worker0: 5858\n    // app_worker1: 5859\n    // ...\n    const opt = { execArgv: process.execArgv.concat([ '--debug-port=5856' ]) };\n    const agentWorker = this.agentWorker = childprocess.fork(agentWorkerFile, args, opt);\n    this.logger.info('[master] Agent Worker:%s start with %j', agentWorker.pid, args);\n\n    // forwarding agent' message to messenger\n    agentWorker.on('message', msg => {\n      if (typeof msg === 'string') msg = { action: msg, data: msg };\n      msg.from = 'agent';\n      this.messenger.send(msg);\n    });\n    agentWorker.on('error', err => {\n      err.name = 'AgentWorkerError';\n      this.logger.error(err);\n    });\n    // agent exit message\n    agentWorker.once('exit', (code, signal) => {\n      this.messenger.send({\n        action: 'agent-exit',\n        data: { code, signal },\n        to: 'master',\n        from: 'agent',\n      });\n    });\n  }\n\n\n  forkAppWorkers() {\n    this.appStartTime = Date.now();\n    this.isAllAppWorkerStarted = false;\n    this.startSuccessCount = 0;\n\n    this.workers = new Map();\n\n    const args = [ JSON.stringify(this.options) ];\n    debug('Start appWorker with args %j', args);\n    cfork({\n      exec: appWorkerFile,\n      args,\n      silent: false,\n      count: this.options.workers,\n      // don't refork in local env\n      refork: this.isProduction,\n    });\n\n    cluster.on('fork', worker => {\n      this.workers.set(worker.process.pid, worker);\n      worker.on('message', msg => {\n        if (typeof msg === 'string') msg = { action: msg, data: msg };\n        msg.from = 'app';\n        this.messenger.send(msg);\n      });\n      this.logger.info('[master] App Worker#%s:%s start, state: %s, current workers: %j',\n        worker.id, worker.process.pid, worker.state, Object.keys(cluster.workers));\n    });\n    cluster.on('disconnect', worker => {\n      this.logger.info('[master] App Worker#%s:%s disconnect, suicide: %s, state: %s, current workers: %j',\n        worker.id, worker.process.pid, worker.suicide, worker.state, Object.keys(cluster.workers));\n    });\n    cluster.on('exit', (worker, code, signal) => {\n      this.messenger.send({\n        action: 'app-exit',\n        data: { workerPid: worker.process.pid, code, signal },\n        to: 'master',\n        from: 'app',\n      });\n    });\n    cluster.on('listening', (worker, address) => {\n      this.messenger.send({\n        action: 'app-start',\n        data: { workerPid: worker.process.pid, address },\n        to: 'master',\n        from: 'app',\n      });\n    });\n  }\n\n  /**\n   * close agent worker, App Worker will closed by cluster\n   *\n   * https://www.exratione.com/2013/05/die-child-process-die/\n   * make sure Agent Worker exit before master exit\n   */\n  killAgentWorker() {\n    if (this.agentWorker) {\n      debug('kill agent worker with signal SIGTERM');\n      this.agentWorker.removeAllListeners();\n      this.agentWorker.kill('SIGTERM');\n    }\n  }\n\n  /**\n   * Agent Worker exit handler\n   * Will exit during startup, and refork during running.\n   * @param {Object} data\n   *  - {Number} code   exit code\n   *  - {String} signal received signal\n   */\n  onAgentExit(data) {\n    this.messenger.send({ action: 'egg-pids', to: 'app', data: [] });\n\n    const err = new Error(util.format('[master] Agent Worker %s died (code: %s, signal: %s)',\n      this.agentWorker.pid, data.code, data.signal));\n    err.name = 'AgentWorkerDiedError';\n    this.logger.error(err);\n\n    // remove all listeners to avoid memory leak\n    this.agentWorker.removeAllListeners();\n    this.agentWorker = null;\n\n    if (this.isStarted) {\n      setTimeout(() => {\n        this.logger.info('[master] Agent Worker restarting');\n        this.forkAgentWorker();\n      }, 1000);\n      this.messenger.send({\n        action: 'agent-worker-died',\n        to: 'parent',\n      });\n    } else {\n      this.logger.error('[master] agent start fail, exit now');\n      process.exit(1);\n    }\n  }\n\n  onAgentStart() {\n    this.messenger.send({ action: 'egg-pids', to: 'app', data: [ this.agentWorker.pid ] });\n    this.messenger.send({ action: 'agent-start', to: 'app' });\n    this.logger.info('[master] Agent Worker started (%sms)',\n      Date.now() - this.agentStartTime);\n  }\n\n  /**\n   * App Worker exit handler\n   * @param {Object} data\n   *  - {String} workerPid - worker id\n   *  - {Number} code - exit code\n   *  - {String} signal - received signal\n   */\n  onAppExit(data) {\n    const worker = this.workers.get(data.workerPid);\n\n    if (!worker.isDevReload) {\n      const signal = data.code;\n      const message = util.format(\n        '[master] App Worker#%s:%s died (code: %s, signal: %s, suicide: %s, state: %s), current workers: %j',\n        worker.id, worker.process.pid, worker.process.exitCode, signal,\n        worker.suicide, worker.state,\n        Object.keys(cluster.workers)\n      );\n      const err = new Error(message);\n      err.name = 'AppWorkerDiedError';\n      this.logger.error(err);\n    }\n\n    // remove all listeners to avoid memory leak\n    worker.removeAllListeners();\n    this.workers.delete(data.workerPid);\n    // send message to agent with alive workers\n    this.messenger.send({ action: 'egg-pids', to: 'agent', data: getListeningWorker(this.workers) });\n\n    if (this.isAllAppWorkerStarted) {\n      // cfork will only refork at production mode\n      this.messenger.send({\n        action: 'app-worker-died',\n        to: 'parent',\n      });\n\n      if (this.isDebug && !worker.isDevReload) {\n        // exit if died during debug\n        this.logger.error('[master] kill by debugger, exit now');\n        process.exit(0);\n      }\n    } else {\n      // exit if died during startup\n      this.logger.error('[master] worker start fail, exit now');\n      process.exit(1);\n    }\n  }\n\n  /**\n   * after app worker\n   * @param {Object} data\n   *  - {String} workerPid - worker id\n   *  - {Object} address - server address\n   */\n  onAppStart(data) {\n    const worker = this.workers.get(data.workerPid);\n    const address = data.address;\n\n    // ignore unspecified port\n    if (!this.options.sticky && (String(address.port) !== String(this.options.port))) {\n      return;\n    }\n\n    // send message to agent with alive workers\n    this.messenger.send({ action: 'egg-pids', to: 'agent', data: getListeningWorker(this.workers) });\n\n    this.startSuccessCount++;\n\n    const remain = this.isAllAppWorkerStarted ? 0 : this.options.workers - this.startSuccessCount;\n    this.logger.warn('[master] App Worker#%s:%s started at %s, remain %s (%sms)',\n      worker.id, data.workerPid, address.port, remain, Date.now() - this.appStartTime);\n\n    if (this.isAllAppWorkerStarted || this.startSuccessCount < this.options.workers) {\n      return;\n    }\n\n    this.isAllAppWorkerStarted = true;\n\n    if (this.options.sticky) {\n      this.startMasterSocketServer(err => {\n        if (err) return this.ready(err);\n        this.ready(true);\n      });\n    } else {\n      this.ready(true);\n    }\n  }\n\n  /**\n   * master exit handler\n   */\n  onExit() {\n    // kill agent worker\n    process.once('exit', code => {\n      // istanbul can't cover here\n      // https://github.com/gotwarlost/istanbul/issues/567\n      this.killAgentWorker();\n      this.logger.info('[master] exit with code: %s', code);\n    });\n\n    // https://nodejs.org/api/process.html#process_signal_events\n    // https://en.wikipedia.org/wiki/Unix_signal\n    // kill(2) Ctrl-C\n    process.once('SIGINT', receiveSig.bind(null, 'SIGINT'));\n    // kill(3) Ctrl-\\\n    process.once('SIGQUIT', receiveSig.bind(null, 'SIGQUIT'));\n    // kill(15) default\n    process.once('SIGTERM', receiveSig.bind(null, 'SIGTERM'));\n\n    function receiveSig(sig) {\n      debug('receive signal %s, exit with code 0, pid %s', sig, process.pid);\n      process.exit(0);\n    }\n  }\n\n  /**\n   * reload workers, for develop purpose\n   */\n  onReload() {\n    this.logger.info('[master] reload workers...');\n    for (const id in cluster.workers) {\n      const worker = cluster.workers[id];\n      worker.isDevReload = true;\n    }\n    require('cluster-reload')(this.options.workers);\n  }\n}\n\nmodule.exports = Master;\n\nfunction getListeningWorker(workers) {\n  const keys = [];\n  for (const id of workers.keys()) {\n    if (workers.get(id).state === 'listening') {\n      keys.push(id);\n    }\n  }\n  return keys;\n}\n\nfunction isProduction() {\n  const serverEnv = process.env.EGG_SERVER_ENV;\n  if (serverEnv) {\n    return serverEnv !== 'local' && serverEnv !== 'unittest';\n  }\n  return process.env.NODE_ENV === 'production';\n}\n\nfunction isDebug() {\n  return process.execArgv.indexOf('--debug') !== -1 || typeof v8debug !== 'undefined';\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/index.js":"'use strict';\n\nmodule.exports.Logger = require('./lib/logger');\n\nmodule.exports.Transport = require('./lib/transports/transport');\nmodule.exports.FileBufferTransport = require('./lib/transports/file_buffer');\nmodule.exports.FileTransport = require('./lib/transports/file');\nmodule.exports.ConsoleTransport = require('./lib/transports/console');\n\nmodule.exports.EggLogger = require('./lib/egg/logger');\nmodule.exports.EggErrorLogger = require('./lib/egg/error_logger');\nmodule.exports.EggConsoleLogger = require('./lib/egg/console_logger');\nmodule.exports.EggCustomLogger = require('./lib/egg/custom_logger');\nmodule.exports.EggContextLogger = require('./lib/egg/context_logger');\nmodule.exports.EggLoggers = require('./lib/egg/loggers');\n\nmodule.exports.levels = require('./lib/level');\nObject.assign(module.exports, module.exports.levels);\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/logger.js":"'use strict';\n\nconst util = require('util');\nconst utils = require('./utils');\nconst depd = require('depd')('egg-logger');\n\n\n/**\n * Base class for all sub Logger class.\n * It extends Map, and can contains multi {@link Transport}\n *\n * @example\n * ```js\n * const logger = new Logger();\n * logger.set('file', new FileTransport({\n *   file: '/path/to/log',\n *   level: 'INFO',\n * }));\n * logger.set('console', new ConsoleTransport({\n *   level: 'INFO',\n * }));\n * logger.info('foo');\n * ```\n */\nclass Logger extends Map {\n\n  /**\n   * @constructor\n   * @param {Object} options - assign with `defaults` propery\n   */\n  constructor(options) {\n    super();\n    this.options = utils.assign(this.defaults, options);\n    this.transports = {};\n    this.name = this.constructor.name;\n    this.redirectLoggers = new Map();\n  }\n\n  /**\n   * disable a transport\n   * @param {String} name - transport name\n   */\n  disable(name) {\n    const transport = this.get(name);\n    if (transport) transport.disable();\n  }\n\n  /**\n   * enable a transport\n   * @param {String} name - transport name\n   */\n  enable(name) {\n    const transport = this.get(name);\n    if (transport) transport.enable();\n  }\n\n  /**\n   * Send log to all transports.\n   * It's proxy to {@link Transport}'s log method.'\n   * @param {String} level - log level\n   * @param {Array} args - log arguments\n   * @param {Object} meta - log meta\n   */\n  log(level, args, meta) {\n    const redirectLogger = this.redirectLoggers.get(level);\n    if (redirectLogger) {\n      redirectLogger.log(level, args, meta);\n      return;\n    }\n\n    for (const transport of this.values()) {\n      if (transport.shouldLog(level)) {\n        transport.log(level, args, meta);\n      }\n    }\n  }\n\n  /**\n   * write raw log to all transports\n   * @param {String} msg - log message\n   */\n  write(msg) {\n    // support util.format\n    if (arguments.length > 1) msg = util.format.apply(util, arguments);\n    // `NONE` is the top level\n    this.log('NONE', [ msg ], { raw: true });\n  }\n\n  /**\n   * Redirect specify level log to the other logger\n   * @param {String} level - log level\n   * @param {Logger} logger - target logger instance\n   */\n  redirect(level, logger) {\n    level = level.toUpperCase();\n    if (!this.redirectLoggers.has(level) && logger instanceof Logger) {\n      this.redirectLoggers.set(level, logger);\n    }\n  }\n\n  /**\n   * Un-redirect specify level log\n   * @param {String} level - log level\n   */\n  unredirect(level) {\n    level = level.toUpperCase();\n    this.redirectLoggers.delete(level);\n  }\n\n  /**\n   * Reload all transports\n   */\n  reload() {\n    for (const transport of this.values()) {\n      transport.reload();\n    }\n  }\n\n  /**\n   * End all transports\n   */\n  close() {\n    for (const transport of this.values()) {\n      transport.close();\n    }\n  }\n\n  /**\n   * @deprecated\n   */\n  end() {\n    depd('logger.end() is deprecated, use logger.close()');\n    this.close();\n  }\n\n}\n\n[ 'error', 'warn', 'info', 'debug' ].forEach(level => {\n  const LEVEL = level.toUpperCase();\n  Logger.prototype[level] = function() {\n    this.log(LEVEL, arguments);\n  };\n});\n\nmodule.exports = Logger;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/utils.js":"'use strict';\n\nconst os = require('os');\nconst util = require('util');\nconst chalk = require('chalk');\nconst utility = require('utility');\nconst iconv = require('iconv-lite');\nconst levels = require('./level');\n\nconst hostname = os.hostname();\nconst duartionRegexp = /([0-9]+ms)/g;\n// eslint-disable-next-line no-useless-escape\nconst categoryRegexp = /(\\[[\\w\\-_.:]+\\])/g;\nconst httpMethodRegexp = /(GET|POST|PUT|PATH|HEAD|DELETE) /g;\n\n/**\n * @class LoggerUtils\n */\nmodule.exports = {\n\n  normalizeLevel(level) {\n    if (typeof level === 'number') {\n      return level;\n    }\n\n    // 'WARN' => level.warn\n    if (typeof level === 'string' && level) {\n      return levels[level.toUpperCase()];\n    }\n  },\n\n  // default format\n  defaultFormatter(meta) {\n    return meta.date + ' ' + meta.level + ' ' + meta.pid + ' ' + meta.message;\n  },\n\n  // output to Terminal format\n  consoleFormatter(meta) {\n    let msg = meta.date + ' ' + meta.level + ' ' + meta.pid + ' ' + meta.message;\n    if (!chalk.supportsColor) {\n      return msg;\n    }\n\n    if (meta.level === 'ERROR') {\n      return chalk.red(msg);\n    } else if (meta.level === 'WARN') {\n      return chalk.yellow(msg);\n    }\n\n    msg = msg.replace(duartionRegexp, chalk.green('$1'));\n    msg = msg.replace(categoryRegexp, chalk.blue('$1'));\n    msg = msg.replace(httpMethodRegexp, chalk.cyan('$1 '));\n    return msg;\n  },\n\n  /**\n   * Get final formated log string buffer\n   *\n   * Invoke linke: {@Link Logger#log} -> {@link Transport#log} -> LoggerUtils.format\n   * @method LoggerUtils#format\n   * @param {String} level - log level\n   * @param {Array} args - format arguments\n   * @param {Object} meta - loging behaviour meta infomation\n   *  - {String} level\n   *  - {Boolean} raw\n   *  - {Function} formatter\n   *  - {Error} error\n   *  - {String} message\n   *  - {Number} pid\n   *  - {String} hostname\n   *  - {String} date\n   * @param {Object} options - {@link Transport}'s options\n   *  - {String} encoding\n   *  - {Boolean} json\n   *  - {Function} formatter\n   * @return {Buffer} formated log string buffer\n   */\n  format(level, args, meta, options) {\n    meta = meta || {};\n    let message;\n    let output;\n    const formatter = meta.formatter || options.formatter;\n\n    if (args[0] instanceof Error) {\n      message = formatError(args[0]);\n    } else {\n      message = util.format.apply(util, args);\n    }\n\n    if (meta.raw === true) {\n      output = message;\n    } else if (options.json === true || formatter) {\n      meta.level = level;\n      meta.date = utility.logDate(',');\n      meta.pid = process.pid;\n      meta.hostname = hostname;\n      meta.message = message;\n      output = options.json === true ? JSON.stringify(meta) : formatter(meta);\n    } else {\n      output = message;\n    }\n\n    if (!output) return new Buffer('');\n\n    output += options.eol;\n\n    // convert string to buffer when encoding is not utf8\n    return options.encoding === 'utf8' ? output : iconv.encode(output, options.encoding);\n  },\n\n  // Like `Object.assign`, but don't copy `undefined` value\n  assign(target) {\n    if (!target) {\n      return {};\n    }\n    const sources = Array.prototype.slice.call(arguments, 1);\n    for (let i = 0; i < sources.length; i++) {\n      const source = sources[i];\n      if (!source) continue;\n      const keys = Object.keys(source);\n      for (let j = 0; j < keys.length; j++) {\n        const key = keys[j];\n        if (source[key] !== undefined && source[key] !== null) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  },\n\n  formatError,\n};\n\nfunction formatError(err) {\n  if (err.name === 'Error' && typeof err.code === 'string') {\n    err.name = err.code + err.name;\n  }\n\n  if (err.host) {\n    err.message += ` (${err.host})`;\n  }\n  err.stack = err.stack || 'no_stack';\n  // name and stack could not be change on node 0.11+\n  const errStack = err.stack;\n  const errProperties = Object.keys(err).map(key => inspect(key, err[key])).join('\\n');\n  return util.format('nodejs.%s: %s\\n%s\\n%s\\npid: %s\\nhostname: %s\\n',\n    err.name,\n    err.message,\n    errStack.substring(errStack.indexOf('\\n') + 1),\n    errProperties,\n    process.pid,\n    hostname\n  );\n}\n\nfunction inspect(key, value) {\n  if (value && typeof value === 'object') {\n    // force in one line\n    value = util.inspect(value)\n      .replace(/^\\s+/mg, '')\n      .replace(/\\n/g, ' ');\n  } else {\n    value = util.inspect(value);\n  }\n  return key + ': ' + value;\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/level.js":"'use strict';\n\nexports.ALL = -Infinity;\n\n/**\n * Debug log for execute tracing\n *\n * @method Logger#debug\n * @param {String} msg - log message\n */\nexports.DEBUG = 0;\n\n/**\n * Normal infomaction loging\n * @method Logger#info\n * @param {String} msg - log message\n */\nexports.INFO = 1;\n\n/**\n * Warning information loging\n * @method Logger#warn\n * @param {String} msg - log message\n */\nexports.WARN = 2;\n\n/**\n * Error or exception loging\n * @method Logger#error\n * @param {String|Error} msg - log message or error instance\n */\nexports.ERROR = 3;\n\nexports.NONE = Infinity;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/transports/transport.js":"'use strict';\n\nconst os = require('os');\nconst utils = require('../utils');\nconst levels = require('../level');\n\nconst ENABLED = Symbol('Transport#enabled');\n\n\n/**\n * Transport 是日志的一种输出通道，可以输出到文件，终端或服务等。\n * 一个 {@link Logger} 可以配置多个 Transport 来满足各种复杂的需求\n */\nclass Transport {\n\n  /**\n   * @constructor\n   * @param  {Object} options\n   * - {String} [level = NONE] - 日志打印级别，打印的方法必须高于此配置方法。如配置了 info，debug 不会打印。\n   * - {Function} formatter - 格式化函数\n   * - {Boolean} [json = false] - 日志内容是否为 json 格式\n   * - {String} [encoding = utf8] - 文件编码，可选编码 {@link https://github.com/ashtuchkin/iconv-lite#supported-encodings}\n   * - {String} [eol = os.EOL] - 换行符\n   */\n  constructor(options) {\n    this.options = utils.assign(this.defaults, options);\n    if (this.options.encoding === 'utf-8') {\n      this.options.encoding = 'utf8';\n    }\n    this.options.level = utils.normalizeLevel(this.options.level);\n    this[ENABLED] = true;\n  }\n\n  get defaults() {\n    return {\n      level: 'NONE',\n      formatter: null,\n      json: false,\n      encoding: 'utf8',\n      eol: os.EOL,\n    };\n  }\n\n  /**\n   * 是否开启，如果关闭则不会输出日志\n   * @return {[type]} [description]\n   */\n  get enabled() {\n    return this[ENABLED];\n  }\n\n  /**\n   * 开启 transport\n   */\n  enable() {\n    this[ENABLED] = true;\n  }\n\n  /**\n   * 关闭 transport，关闭后不会写入日志\n   */\n  disable() {\n    this[ENABLED] = false;\n  }\n\n  /**\n   * 是否应该打印日志\n   * @param  {String} level 日志级别，必须大写\n   * @return {Boolean} 返回打印状态\n   */\n  shouldLog(level) {\n    if (!this[ENABLED]) {\n      return false;\n    }\n\n    // 如果指定了 NONE 就不打印\n    if (this.options.level === levels['NONE']) {\n      return false;\n    }\n\n    return this.options.level <= levels[level];\n  }\n\n  /**\n   * Transport 统一的记录日志的方法，会根据配置输出不同格式\n   * @param  {String} level - 日志级别\n   * @param  {Array} args - 所有的参数\n   * @param  {Object} meta - 元信息\n   * @return {Buffer|String} 日志信息 - 如果无内容会返回空字符串, utf8编码返回 String, 其他编码返回 Buffer\n   */\n  log(level, args, meta) {\n    return utils.format(level, args, meta, this.options);\n  }\n\n  /**\n   * 重载 Transport，无特殊情况可不覆盖\n   */\n  reload() {}\n\n  /**\n   * 关闭 Transport，无特殊情况可不覆盖\n   */\n  close() {}\n  end() {}\n}\n\nmodule.exports = Transport;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/transports/file_buffer.js":"'use strict';\n\nconst depd = require('depd')('egg-logger');\nconst FileTransport = require('./file');\nconst utils = require('../utils');\n\n/**\n * 继承自 {@link FileTransport}，将日志写入内存中，一定时间内统一写入文件来提高性能\n */\nclass FileBufferTransport extends FileTransport {\n\n  /**\n   * @constructor\n   * @param {Object} options\n   * - {String} file - 日志的文件路径\n   * - {Number} [flushInterval = 1000] - 日志写入频率，一定时间后写入文件\n   * - {Number} [maxBufferLength = 1000] - 日志写入缓存队列最大长度\n   * - {String} [level = INFO] - 日志级别\n   */\n  constructor(options) {\n    super(options);\n\n    this._bufSize = 0;\n    this._buf = [];\n    this._timer = this._createInterval();\n  }\n\n  get defaults() {\n    return utils.assign(super.defaults, {\n      flushInterval: 1000,\n      maxBufferLength: 1000,\n    });\n  }\n\n  /**\n   * 关闭 stream 和定时器\n   */\n  close() {\n    this._closeInterval();\n    super.close();\n  }\n\n  /**\n   * @deprecated\n   */\n  end() {\n    depd('transport.end() is deprecated, use transport.close()');\n    this.close();\n  }\n\n  /**\n   * 将内存中的字符写入文件中\n   */\n  flush() {\n    if (this._buf.length > 0) {\n      if (this.options.encoding === 'utf8') {\n        this._stream.write(this._buf.join(''));\n      } else {\n        this._stream.write(Buffer.concat(this._buf, this._bufSize));\n      }\n      this._buf = [];\n      this._bufSize = 0;\n    }\n  }\n\n  /**\n   * 覆盖父类，在关闭 stream 之前先 flush 下\n   * @private\n   */\n  _closeStream() {\n    // FileTransport 在初始化时会 reload，这时 _buf 还未初始化\n    if (this._buf && this._buf.length > 0) {\n      this.flush();\n    }\n    super._closeStream();\n  }\n\n  /**\n   * 覆盖父类，写入内存\n   * @param {Buffer} buf - 日志内容\n   * @private\n   */\n  _write(buf) {\n    this._bufSize += buf.length;\n    this._buf.push(buf);\n    if (this._buf.length > this.options.maxBufferLength) {\n      this.flush();\n    }\n  }\n\n  /**\n   * 创建定时器，一定时间内写入文件\n   * @return {Interval} 定时器\n   * @private\n   */\n  _createInterval() {\n    return setInterval(() => this.flush(), this.options.flushInterval);\n  }\n\n  /**\n   * 关闭定时器\n   * @private\n   */\n  _closeInterval() {\n    if (this._timer) {\n      clearInterval(this._timer);\n      this._timer = null;\n    }\n  }\n}\n\nmodule.exports = FileBufferTransport;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/transports/file.js":"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst assert = require('assert');\nconst mkdirp = require('mkdirp');\nconst utility = require('utility');\nconst depd = require('depd')('egg-logger');\nconst Transport = require('./transport');\nconst utils = require('../utils');\n\n\n/**\n * 将日志输出到文件的 {@link Transport}。\n */\nclass FileTransport extends Transport {\n\n  /**\n   * @constructor\n   * @param {Object} options\n   * - {String} file - 日志的文件路径\n   * - {String} [level = INFO] - 日志级别\n   */\n  constructor(options) {\n    super(options);\n    assert(this.options.file, 'should pass options.file');\n\n    this._stream = null;\n    this.reload();\n  }\n\n  get defaults() {\n    return utils.assign(super.defaults, {\n      file: null,\n      level: 'INFO',\n    });\n  }\n\n  /**\n   * 重新载入日志文件\n   */\n  reload() {\n    // 关闭原来的 stream\n    this._closeStream();\n    // 新创建一个 stream\n    this._stream = this._createStream();\n  }\n\n  /**\n   * 输出日志，见 {@link Transport#log}\n   * @param  {String} level - 日志级别\n   * @param  {Array} args - 所有的参数\n   * @param  {Object} meta - 元信息\n   */\n  log(level, args, meta) {\n    if (!this._stream) {\n      const err = new Error(`${this.options.file} log stream had been closed`);\n      console.error(err.stack);\n      return;\n    }\n    const buf = super.log(level, args, meta);\n    if (buf.length) {\n      this._write(buf);\n    }\n  }\n\n  /**\n   * 关闭 stream\n   */\n  close() {\n    this._closeStream();\n  }\n\n  /**\n   * @deprecated\n   */\n  end() {\n    depd('transport.end() is deprecated, use transport.close()');\n    this.close();\n  }\n\n  /**\n   * 直接写入 stream\n   * @param {Buffer|String} buf - 日志内容\n   * @private\n   */\n  _write(buf) {\n    this._stream.write(buf);\n  }\n\n  /**\n   * 创建一个 stream\n   * @return {Stream} 返回一个 writeStream\n   * @private\n   */\n  _createStream() {\n    mkdirp.sync(path.dirname(this.options.file));\n    const stream = fs.createWriteStream(this.options.file, { flags: 'a' });\n    stream.on('error', onError);\n    return stream;\n  }\n\n  /**\n   * 关闭 stream\n   * @private\n   */\n  _closeStream() {\n    if (this._stream) {\n      this._stream.end();\n      this._stream.removeListener('error', onError);\n      this._stream = null;\n    }\n  }\n\n}\n\nmodule.exports = FileTransport;\n\nfunction onError(err) {\n  console.error('%s ERROR %s [chair-logger:buffer_write_stream] %s: %s\\n%s',\n    utility.logDate(','), process.pid, err.name, err.message, err.stack);\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/transports/console.js":"'use strict';\n\nconst Transport = require('./transport');\nconst utils = require('../utils');\nconst levels = require('../level');\n\n\n/**\n * 将日志输出到终端的 {@link Transport}。\n * 如果指定 EGG_LOG 则是优先级最高的 level。\n */\nclass ConsoleTransport extends Transport {\n\n  /**\n   * @constructor\n   * @param {Object} options\n   * - {Array} [stderrLevel = ERROR] - 输出到 stderr 的打印级别，必须高于 level\n   */\n  constructor(options) {\n    super(options);\n    this.options.stderrLevel = utils.normalizeLevel(this.options.stderrLevel);\n    // EGG_LOG 优先级最高\n    if (process.env.EGG_LOG) {\n      this.options.level = utils.normalizeLevel(process.env.EGG_LOG);\n    }\n  }\n\n  get defaults() {\n    return utils.assign(super.defaults, {\n      stderrLevel: 'ERROR',\n    });\n  }\n\n  /**\n   * 输出日志，见 {@link Transport#log}，如果指定了 stderrLevel 会将日志转到 stderr\n   * @param  {String} level - 日志级别，必须大写\n   * @param  {Array} args - 所有的参数\n   * @param  {Object} meta - 元信息\n   */\n  log(level, args, meta) {\n    const msg = super.log(level, args, meta);\n    if (levels[level] >= this.options.stderrLevel && levels[level] < levels['NONE']) {\n      process.stderr.write(msg);\n    } else {\n      process.stdout.write(msg);\n    }\n  }\n\n}\n\nmodule.exports = ConsoleTransport;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/egg/logger.js":"'use strict';\n\nconst Logger = require('../logger');\nconst utils = require('../utils');\nconst FileTransport = require('../transports/file');\nconst FileBufferTransport = require('../transports/file_buffer');\nconst ConsoleTransport = require('../transports/console');\n\n/**\n * Support three transports: Console, File and JSON File\n */\n\nclass EggLogger extends Logger {\n  /**\n   * @constructor\n   * @param {Object} options\n   *  - {String} file - log file\n   *  - {String} [encoding = utf8] - log string encoding\n   *  - {String} [level = INFO] - file log level\n   *  - {String} [consoleLevel = NONE] - console log level\n   *  - {Function} [formatter] - log format function\n   *  - {String} [jsonFile] - JSON log file\n   *  - {Boolean} [outputJSON = false] - send JSON log or not\n   *  - {Boolean} [buffer] - use {@link FileBufferTransport} or not\n   *  - {String} [eol] - end of line char\n   */\n  constructor(options) {\n    super(options);\n\n    if (this.options.outputJSON === true && this.options.file) {\n      this.options.jsonFile = this.options.file.replace(/\\.log$/, '.json.log');\n    }\n\n    const EggFileTransport = this.options.buffer === true ? FileBufferTransport : FileTransport;\n\n    const fileTransport = new EggFileTransport({\n      file: this.options.file,\n      level: this.options.level || 'INFO',\n      encoding: this.options.encoding,\n      formatter: this.options.formatter,\n      flushInterval: this.options.flushInterval,\n      eol: this.options.eol,\n    });\n    this.set('file', fileTransport);\n\n    if (this.options.jsonFile) {\n      const jsonFileTransport = new EggFileTransport({\n        file: this.options.jsonFile,\n        level: this.options.level,\n        encoding: this.options.encoding,\n        flushInterval: this.options.flushInterval,\n        json: true,\n        eol: this.options.eol,\n      });\n      this.set('jsonFile', jsonFileTransport);\n    }\n\n    const consoleTransport = new ConsoleTransport({\n      level: this.options.consoleLevel,\n      formatter: utils.consoleFormatter,\n      eol: this.options.eol,\n    });\n    this.set('console', consoleTransport);\n  }\n\n  get defaults() {\n    return {\n      file: null,\n      encoding: 'utf8',\n      level: 'INFO',\n      consoleLevel: 'NONE',\n      formatter: utils.defaultFormatter,\n      buffer: true,\n      outputJSON: false,\n      jsonFile: '',\n    };\n  }\n}\n\nmodule.exports = EggLogger;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/egg/error_logger.js":"'use strict';\n\nconst Logger = require('./logger');\nconst levels = require('../level');\nconst utils = require('../utils');\n\n\n/**\n * Error Logger, only print `ERROR` level log.\n * level and consoleLevel should >= `ERROR` level.\n */\nclass ErrorLogger extends Logger {\n  constructor(options) {\n    options = options || {};\n    options.level = getDefaultLevel(options.level);\n    options.consoleLevel = getDefaultLevel(options.consoleLevel);\n    super(options);\n  }\n}\n\nmodule.exports = ErrorLogger;\n\nfunction getDefaultLevel(level) {\n  level = utils.normalizeLevel(level);\n\n  if (level === undefined) {\n    return levels.ERROR;\n  }\n\n  return level > levels.ERROR ? level : levels.ERROR;\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/egg/console_logger.js":"'use strict';\n\nconst Logger = require('../logger');\nconst ConsoleTransport = require('../transports/console');\nconst utils = require('../utils');\n\n/**\n * Terminal Logger, send log to console.\n */\nclass ConsoleLogger extends Logger {\n\n  /**\n   * @constructor\n   * @param {Object} options\n   * - {String} [encoding] - log string encoding, default is 'utf8'\n   */\n  constructor(options) {\n    super(options);\n\n    this.set('console', new ConsoleTransport({\n      level: this.options.level,\n      formatter: utils.consoleFormatter,\n    }));\n  }\n\n  get defaults() {\n    return {\n      encoding: 'utf8',\n      level: process.env.NODE_ENV === 'production' ? 'INFO' : 'WARN',\n    };\n  }\n\n}\n\nmodule.exports = ConsoleLogger;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/egg/custom_logger.js":"'use strict';\n\nconst Logger = require('./logger');\n\n/**\n * Custom Logger\n */\nclass CustomLogger extends Logger {}\n\nmodule.exports = CustomLogger;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/egg/context_logger.js":"'use strict';\n\n/**\n * Request context Logger, itself isn't a {@link Logger}.\n */\nclass ContextLogger {\n\n  /**\n   * @constructor\n   * @param {Context} ctx - egg Context instance\n   * @param {Logger} logger - Logger instance\n   */\n  constructor(ctx, logger) {\n    this.ctx = ctx;\n    this._logger = logger;\n  }\n\n  get paddingMessage() {\n    const ctx = this.ctx;\n\n    // Auto record necessary request context infomation, e.g.: user id, request spend time\n    // format: '[$userId/$ip/$traceId/$use_ms $method $url]'\n    const userId = ctx.userId || '-';\n    const traceId = ctx.tracer && ctx.tracer.traceId || '-';\n    const use = ctx.starttime ? Date.now() - ctx.starttime : 0;\n    return '[' +\n      userId + '/' +\n      ctx.ip + '/' +\n      traceId + '/' +\n      use + 'ms ' +\n      ctx.method + ' ' +\n      ctx.url +\n    ']';\n  }\n\n  write(msg) {\n    this._logger.write(msg);\n  }\n}\n\n[ 'error', 'warn', 'info', 'debug' ].forEach(level => {\n  const LEVEL = level.toUpperCase();\n  ContextLogger.prototype[level] = function() {\n    const meta = {\n      formatter: contextFormatter,\n      paddingMessage: this.paddingMessage,\n    };\n    this._logger.log(LEVEL, arguments, meta);\n  };\n});\n\nmodule.exports = ContextLogger;\n\nfunction contextFormatter(meta) {\n  return meta.date + ' ' + meta.level + ' ' + meta.pid + ' ' + meta.paddingMessage + ' ' + meta.message;\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-logger/lib/egg/loggers.js":"'use strict';\n\nconst path = require('path');\nconst assert = require('assert');\nconst debug = require('debug')('egg:logger');\nconst utils = require('../utils');\nconst Logger = require('./logger');\nconst ErrorLogger = require('./error_logger');\nconst CustomLogger = require('./custom_logger');\n\n\nconst defaults = {\n  env: 'default',\n  type: '',\n  dir: '',\n  encoding: 'utf8',\n  level: 'INFO',\n  consoleLevel: 'NONE',\n  outputJSON: false,\n  buffer: true,\n  appLogName: '',\n  coreLogName: '',\n  agentLogName: '',\n  errorLogName: '',\n};\n\n/**\n * Logger Manager, accord config to create multi loggers.\n */\n\nclass Loggers extends Map {\n\n  /**\n   * @constructor\n   * @param  {Object} config - egg app config\n   * - logger\n   *   - {String} env - egg app runtime env string, detail please see `app.config.env`\n   *   - {String} type - current process type, `application` or `agent`\n   *   - {String} dir - log file dir\n   *   - {String} [encoding = utf8] - log string encoding\n   *   - {String} [level = INFO] - file log level\n   *   - {String} [consoleLevel = NONE] - console log level\n   *   - {Boolean} [outputJSON = false] - send JSON log or not\n   *   - {Boolean} [buffer = true] - use {@link FileBufferTransport} or not\n   *   - {String} appLogName - egg app file logger name\n   *   - {String} coreLogName - egg core file logger name\n   *   - {String} agentLogName - egg agent file logger name\n   *   - {String} errorLogName - err common error logger name\n   *   - {String} eol - end of line char\n   * - customLogger\n   */\n  constructor(config) {\n    super();\n\n    const loggerConfig = utils.assign({}, defaults, config.logger);\n    const customLoggerConfig = config.customLogger;\n\n    debug('Init loggers with options %j', loggerConfig);\n    assert(loggerConfig.type, 'should pass config.logger.type');\n    assert(loggerConfig.dir, 'should pass config.logger.dir');\n    assert(loggerConfig.appLogName, 'should pass config.logger.appLogName');\n    assert(loggerConfig.coreLogName, 'should pass config.logger.coreLogName');\n    assert(loggerConfig.agentLogName, 'should pass config.logger.agentLogName');\n    assert(loggerConfig.errorLogName, 'should pass config.logger.errorLogName');\n\n    const errorLogger = new ErrorLogger(utils.assign({}, loggerConfig, {\n      file: path.join(loggerConfig.dir, loggerConfig.errorLogName),\n    }));\n    this.set('errorLogger', errorLogger);\n\n    if (loggerConfig.type === 'agent') {\n      const logger = new Logger(utils.assign({}, loggerConfig, {\n        file: path.join(loggerConfig.dir, loggerConfig.agentLogName),\n      }));\n      this.set('logger', logger);\n\n      const coreLogger = new Logger(utils.assign({}, loggerConfig, loggerConfig.coreLogger, {\n        file: path.join(loggerConfig.dir, loggerConfig.agentLogName),\n      }));\n      this.set('coreLogger', coreLogger);\n    } else {\n      const logger = new Logger(utils.assign({}, loggerConfig, {\n        file: path.join(loggerConfig.dir, loggerConfig.appLogName),\n      }));\n      this.set('logger', logger);\n\n      const coreLogger = new Logger(utils.assign({}, loggerConfig, loggerConfig.coreLogger, {\n        file: path.join(loggerConfig.dir, loggerConfig.coreLogName),\n      }));\n      this.set('coreLogger', coreLogger);\n    }\n\n    for (const name in customLoggerConfig) {\n      const logger = new CustomLogger(utils.assign({}, loggerConfig, customLoggerConfig[name]));\n      this.set(name, logger);\n    }\n  }\n\n  /**\n   * Disable console logger\n   */\n  disableConsole() {\n    for (const logger of this.values()) {\n      logger.disable('console');\n    }\n  }\n\n  reload() {\n    for (const logger of this.values()) {\n      logger.reload();\n    }\n  }\n\n  /**\n   * Add a logger\n   * @param {String} name - logger name\n   * @param {Logger} logger - Logger instance\n   */\n  set(name, logger) {\n    if (this.has(name)) {\n      return;\n    }\n\n    // redirect ERROR log to errorLogger, except errorLogger itself\n    if (name !== 'errorLogger') {\n      logger.redirect('error', this.errorLogger);\n    }\n    this[name] = logger;\n    super.set(name, logger);\n  }\n\n}\n\nmodule.exports = Loggers;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-cluster/lib/utils/options.js":"'use strict';\n\nconst os = require('os');\nconst fs = require('fs');\nconst path = require('path');\nconst assert = require('assert');\nconst utils = require('egg-utils');\n\n\nmodule.exports = function(options) {\n  const defaults = {\n    framework: '',\n    baseDir: process.cwd(),\n    port: options.https ? 8443 : 7001,\n    workers: null,\n    plugins: null,\n    https: false,\n    key: '',\n    cert: '',\n  };\n  options = extend(defaults, options);\n  if (!options.workers) {\n    options.workers = os.cpus().length;\n  }\n\n  const pkgPath = path.join(options.baseDir, 'package.json');\n  assert(fs.existsSync(pkgPath), `${pkgPath} should exist`);\n\n  options.framework = utils.getFrameworkPath({\n    baseDir: options.baseDir,\n    // compatible customEgg only when call startCluster directly without framework\n    framework: options.framework || options.customEgg,\n  });\n\n  const egg = require(options.framework);\n  assert(egg.Application, `should define Application in ${options.framework}`);\n  assert(egg.Agent, `should define Agent in ${options.framework}`);\n\n  if (options.https) {\n    assert(options.key && fs.existsSync(options.key), 'options.key should exists');\n    assert(options.cert && fs.existsSync(options.cert), 'options.cert should exists');\n  }\n\n  options.port = parseInt(options.port, 10);\n  options.workers = parseInt(options.workers, 10);\n\n  // don't print depd message in production env.\n  // it will print to stderr.\n  if (process.env.NODE_ENV === 'production') {\n    process.env.NO_DEPRECATION = '*';\n  }\n\n  return options;\n};\n\nfunction extend(target, src) {\n  const keys = Object.keys(src);\n  for (const key of keys) {\n    if (src[key] != null) {\n      target[key] = src[key];\n    }\n  }\n  return target;\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-utils/index.js":"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\n[\n  require('./lib/framework'),\n  { getFrameworkOrEggPath },\n]\n.forEach(obj => Object.assign(exports, obj));\n\n/**\n * Try to get framework dir path\n * If can't find any framework, try to find egg dir path\n *\n * @param {String} cwd - current work path\n * @param {Array} [eggNames] - egg names, default is ['egg']\n * @return {String} framework or egg dir path\n * @deprecated\n */\nfunction getFrameworkOrEggPath(cwd, eggNames) {\n  eggNames = eggNames || [ 'egg' ];\n  const moduleDir = path.join(cwd, 'node_modules');\n  if (!fs.existsSync(moduleDir)) {\n    return '';\n  }\n\n  // try to get framework\n\n  // 1. try to read egg.framework property on package.json\n  const pkgFile = path.join(cwd, 'package.json');\n  if (fs.existsSync(pkgFile)) {\n    const pkg = require(pkgFile);\n    if (pkg.egg && pkg.egg.framework) {\n      return path.join(moduleDir, pkg.egg.framework);\n    }\n  }\n\n  // 2. try the module dependencies includes eggNames\n  const names = fs.readdirSync(moduleDir);\n  for (const name of names) {\n    const pkgfile = path.join(moduleDir, name, 'package.json');\n    if (!fs.existsSync(pkgfile)) {\n      continue;\n    }\n    const pkg = require(pkgfile);\n    if (pkg.dependencies) {\n      for (const eggName of eggNames) {\n        if (pkg.dependencies[eggName]) {\n          return path.join(moduleDir, name);\n        }\n      }\n    }\n  }\n\n  // try to get egg\n  for (const eggName of eggNames) {\n    const pkgfile = path.join(moduleDir, eggName, 'package.json');\n    if (fs.existsSync(pkgfile)) {\n      return path.join(moduleDir, eggName);\n    }\n  }\n\n  return '';\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-utils/lib/framework.js":"'use strict';\n\nconst path = require('path');\nconst assert = require('assert');\nconst fs = require('fs');\n\nconst initCwd = process.cwd();\n\nmodule.exports = { getFrameworkPath };\n\n/**\n * Find the framework directory, lookup order\n * - specify framework path\n * - get framework name from\n * - use egg by default\n * @param {Object} options - options\n * @param  {String} options.baseDir - the current directory of application\n * @param  {String} [options.framework] - the directory of framework\n * @return {String} frameworkPath\n */\nfunction getFrameworkPath({ framework, baseDir }) {\n  const pkgPath = path.join(baseDir, 'package.json');\n  assert(fs.existsSync(pkgPath), `${pkgPath} should exist`);\n\n  const moduleDir = path.join(baseDir, 'node_modules');\n  const pkg = require(pkgPath);\n\n  // 1. pass framework or customEgg\n  if (framework) {\n    // 1.1 framework is an absolute path\n    // framework: path.join(baseDir, 'node_modules/${frameworkName}')\n    if (path.isAbsolute(framework)) {\n      assert(fs.existsSync(framework), `${framework} should exist`);\n      return framework;\n    }\n    // 1.2 framework is a npm package that required by application\n    // framework: 'frameworkName'\n    return assertAndReturn(framework, moduleDir);\n  }\n\n  // 2. framework is not specified\n  // 2.1 use framework name from pkg.egg.framework\n  if (pkg.egg && pkg.egg.framework) {\n    return assertAndReturn(pkg.egg.framework, moduleDir);\n  }\n\n  // 2.2 use egg by default\n  return assertAndReturn('egg', moduleDir);\n}\n\nfunction assertAndReturn(frameworkName, moduleDir) {\n  const moduleDirs = new Set([\n    moduleDir,\n    // find framework from process.cwd, especially for test,\n    // the application is in test/fixtures/app,\n    // and framework is install in ${cwd}/node_modules\n    path.join(process.cwd(), 'node_modules'),\n    // prevent from mocking process.cwd\n    path.join(initCwd, 'node_modules'),\n  ]);\n  for (const moduleDir of moduleDirs) {\n    const frameworkPath = path.join(moduleDir, frameworkName);\n    if (fs.existsSync(frameworkPath)) return frameworkPath;\n  }\n  throw new Error(`${frameworkName} is not found in ${Array.from(moduleDirs)}`);\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-cluster/lib/utils/messenger.js":"'use strict';\n\nconst cluster = require('cluster');\nconst sendmessage = require('sendmessage');\nconst debug = require('debug')('egg-cluster:messenger');\n\n\n/**\n * master messenger,provide communication between parent, master, agent and app.\n *\n *             ┌────────┐\n *             │ parent │\n *            /└────────┘\\\n *           /     |      \\\n *          /  ┌────────┐  \\\n *         /   │ master │   \\\n *        /    └────────┘    \\\n *       /     /         \\    \\\n *     ┌───────┐         ┌───────┐\n *     │ agent │ ------- │  app  │\n *     └───────┘         └───────┘\n *\n *\n * in app worker\n *\n * ```js\n * process.send({\n *   action: 'xxx',\n *   data: '',\n *   to: 'agent/master/parent', // default to app\n * });\n * ```\n *\n * in agent worker\n *\n * ```js\n * process.send({\n *   action: 'xxx',\n *   data: '',\n *   to: 'app/master/parent', // default to agent\n * });\n * ```\n *\n * in parent\n *\n * ```js\n * process.send({\n *   action: 'xxx',\n *   data: '',\n *   to: 'app/agent/master', // default to be ignore\n * });\n * ```\n */\nclass Messenger {\n\n  constructor(master) {\n    this.master = master;\n    process.on('message', msg => {\n      msg.from = 'parent';\n      this.send(msg);\n    });\n  }\n\n  /**\n   * send message\n   * @param {Object} data message body\n   *  - {String} from from who\n   *  - {String} to to who\n   */\n  send(data) {\n    if (!data.from) {\n      data.from = 'master';\n    }\n\n    // default from -> to rules\n    if (!data.to) {\n      if (data.from === 'agent') data.to = 'app';\n      if (data.from === 'app') data.to = 'agent';\n      if (data.from === 'parent') data.to = 'master';\n    }\n\n    // app -> master\n    // agent -> master\n    if (data.to === 'master') {\n      debug('%s -> master, data: %j', data.from, data);\n      // app/agent to master\n      this.sendToMaster(data);\n      return;\n    }\n\n    // master -> parent\n    // app -> parent\n    // agent -> parent\n    if (data.to === 'parent') {\n      debug('%s -> parent, data: %j', data.from, data);\n      this.sendToParent(data);\n      return;\n    }\n\n    // parent -> master -> app\n    // agent -> master -> app\n    if (data.to === 'app') {\n      debug('%s -> %s, data: %j', data.from, data.to, data);\n      this.sendToAppWorker(data);\n      return;\n    }\n\n    // parent -> master -> agent\n    // app -> master -> agent，可能不指定 to\n    if (data.to === 'agent') {\n      debug('%s -> %s, data: %j', data.from, data.to, data);\n      this.sendToAgentWorker(data);\n      return;\n    }\n  }\n\n  /**\n   * send message to master self\n   * @param {Object} data message body\n   */\n  sendToMaster(data) {\n    this.master.emit(data.action, data.data);\n  }\n\n  /**\n   * send message to parent process\n   * @param {Object} data message body\n   */\n  sendToParent(data) {\n    process.send && process.send(data);\n  }\n\n  /**\n   * send message to app worker\n   * @param {Object} data message body\n   */\n  sendToAppWorker(data) {\n    for (const id in cluster.workers) {\n      const worker = cluster.workers[id];\n      if (worker.state === 'disconnected') {\n        continue;\n      }\n      // check receiverPid\n      if (data.receiverPid && data.receiverPid !== String(worker.process.pid)) {\n        continue;\n      }\n      sendmessage(worker, data);\n    }\n  }\n\n  /**\n   * send message to agent worker\n   * @param {Object} data message body\n   */\n  sendToAgentWorker(data) {\n    if (this.master.agentWorker) {\n      sendmessage(this.master.agentWorker, data);\n    }\n  }\n\n}\n\nmodule.exports = Messenger;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/application.js":"'use strict';\n\nconst path = require('path');\nconst graceful = require('graceful');\nconst http = require('http');\nconst EggApplication = require('./egg');\nconst AppWorkerLoader = require('./loader').AppWorkerLoader;\nconst cluster = require('cluster-client');\nconst { assign } = require('utility');\n\nconst KEYS = Symbol('Application#keys');\nconst HELPER = Symbol('Application#Helper');\nconst LOCALS = Symbol('Application#locals');\nconst LOCALS_LIST = Symbol('Application#localsList');\nconst EGG_LOADER = Symbol.for('egg#loader');\nconst EGG_PATH = Symbol.for('egg#eggPath');\nconst CLUSTER_CLIENTS = Symbol.for('egg#clusterClients');\n\n/**\n * Singleton instance in App Worker, extend {@link EggApplication}\n * @extends EggApplication\n */\nclass Application extends EggApplication {\n\n  /**\n   * @constructor\n   * @param {Object} options - see {@link EggApplication}\n   */\n  constructor(options = {}) {\n    options.type = 'application';\n    super(options);\n\n    try {\n      this.loader.load();\n    } catch (e) {\n      // close gracefully\n      this[CLUSTER_CLIENTS].forEach(cluster.close);\n      throw e;\n    }\n\n    // dump config after loaded, ensure all the dynamic modifications will be recorded\n    this.dumpConfig();\n    this.warnConfusedConfig();\n    this.bindEvents();\n  }\n\n  get [EGG_LOADER]() {\n    return AppWorkerLoader;\n  }\n\n  get [EGG_PATH]() {\n    return path.join(__dirname, '..');\n  }\n\n  onServer(server) {\n    /* istanbul ignore next */\n    graceful({\n      server: [ server ],\n      error: (err, throwErrorCount) => {\n        if (err.message) {\n          err.message += ' (uncaughtException throw ' + throwErrorCount + ' times on pid:' + process.pid + ')';\n        }\n        this.coreLogger.error(err);\n      },\n    });\n  }\n\n  /**\n   * global locals for view\n   * @member {Object} Application#locals\n   * @see Context#locals\n   */\n  get locals() {\n    if (!this[LOCALS]) {\n      this[LOCALS] = {};\n    }\n    if (this[LOCALS_LIST] && this[LOCALS_LIST].length) {\n      assign(this[LOCALS], this[LOCALS_LIST]);\n      this[LOCALS_LIST] = null;\n    }\n    return this[LOCALS];\n  }\n\n  set locals(val) {\n    if (!this[LOCALS_LIST]) {\n      this[LOCALS_LIST] = [];\n    }\n    this[LOCALS_LIST].push(val);\n  }\n\n  /**\n   * Create egg context\n   * @method Application#createContext\n   * @param  {Req} req - node native Request object\n   * @param  {Res} res - node native Response object\n   * @return {Context} context object\n   */\n  createContext(req, res) {\n    const app = this;\n    const context = Object.create(app.context);\n    const request = context.request = Object.create(app.request);\n    const response = context.response = Object.create(app.response);\n    context.app = request.app = response.app = app;\n    context.req = request.req = response.req = req;\n    context.res = request.res = response.res = res;\n    request.ctx = response.ctx = context;\n    request.response = response;\n    response.request = request;\n    context.onerror = context.onerror.bind(context);\n    context.originalUrl = request.originalUrl = req.url;\n\n    /**\n     * Request start time\n     * @member {Number} Context#starttime\n     */\n    context.starttime = Date.now();\n    return context;\n  }\n\n  /**\n   * Create an anonymouse context, the context isn't request level, so the request is mocked.\n   * then you can use context level API like `ctx.service`\n   * @member {String} Application#createAnonymousContext\n   * @param {Request} req - if you want to mock request like querystring, you can pass an object to this function.\n   * @return {Context} context\n   */\n  createAnonymousContext(req) {\n    const request = {\n      headers: {\n        'x-forwarded-for': '127.0.0.1',\n      },\n      query: {},\n      querystring: '',\n      host: '127.0.0.1',\n      hostname: '127.0.0.1',\n      protocol: 'http',\n      secure: 'false',\n      method: 'GET',\n      url: '/',\n      path: '/',\n      socket: {\n        remoteAddress: '127.0.0.1',\n        remotePort: 7001,\n      },\n    };\n    if (req) {\n      for (const key in req) {\n        if (key === 'headers' || key === 'query' || key === 'socket') {\n          Object.assign(request[key], req[key]);\n        } else {\n          request[key] = req[key];\n        }\n      }\n    }\n    const response = new http.ServerResponse(request);\n    return this.createContext(request, response);\n  }\n\n  /**\n   * Run generator function in the background\n   * @see Context#runInBackground\n   * @param {Generator} scope - generator function, the first args is an anonymous ctx\n   */\n  runInBackground(scope) {\n    const ctx = this.createAnonymousContext();\n    ctx.runInBackground(scope);\n  }\n\n  /**\n   * secret key for Application\n   * @member {String} Application#keys\n   */\n  get keys() {\n    if (!this[KEYS]) {\n      if (!this.config.keys) {\n        if (this.config.env === 'local' || this.config.env === 'unittest') {\n          const configPath = path.join(this.config.baseDir, 'config/config.default.js');\n          console.error('Cookie need secret key to sign and encrypt.');\n          console.error('Please add `config.keys` in %s', configPath);\n        }\n        throw new Error('Please set config.keys first');\n      }\n\n      this[KEYS] = this.config.keys.split(',').map(s => s.trim());\n    }\n    return this[KEYS];\n  }\n\n  /**\n   * The helper class, `app/helper` will be loaded to it's prototype,\n   * then you can use all method on `ctx.helper`\n   * @member {Helper} Application#Helper\n   */\n  get Helper() {\n    if (!this[HELPER]) {\n      this[HELPER] = class Helper extends this.BaseContextClass {};\n    }\n    return this[HELPER];\n  }\n\n  /**\n   * bind app's events\n   *\n   * @private\n   */\n  bindEvents() {\n    // Browser Cookie Limits: http://browsercookielimits.squawky.net/\n    this.on('cookieLimitExceed', ({ name, value, ctx }) => {\n      const err = new Error(`cookie ${name}'s length(${value.length}) exceed the limit(4093)`);\n      err.name = 'CookieLimitExceedError';\n      err.cookie = value;\n      ctx.coreLogger.error(err);\n    });\n    // expose server to support websocket\n    this.on('server', server => this.onServer(server));\n  }\n\n  /**\n   * warn when confused configurations are present\n   *\n   * @private\n   */\n  warnConfusedConfig() {\n    const confusedConfigurations = this.config.confusedConfigurations;\n    Object.keys(confusedConfigurations).forEach(key => {\n      if (this.config[key] !== undefined) {\n        this.logger.warn('Unexpected config key `%s` exists, Please use `%s` instead.',\n        key, confusedConfigurations[key]);\n      }\n    });\n  }\n}\n\nmodule.exports = Application;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/egg.js":"'use strict';\n\nconst path = require('path');\nconst fs = require('fs');\nconst EggCore = require('egg-core').EggCore;\nconst cluster = require('cluster-client');\nconst extend = require('extend2');\nconst ContextLogger = require('egg-logger').EggContextLogger;\nconst ContextCookies = require('egg-cookies');\nconst ContextHttpClient = require('./core/context_httpclient');\nconst Messenger = require('./core/messenger');\nconst createHttpClient = require('./core/httpclient');\nconst createLoggers = require('./core/logger');\nconst Singleton = require('./core/singleton');\nconst utils = require('./core/utils');\n\nconst HTTPCLIENT = Symbol('EggApplication#httpclient');\nconst LOGGERS = Symbol('EggApplication#loggers');\nconst EGG_PATH = Symbol.for('egg#eggPath');\nconst CLUSTER_CLIENTS = Symbol.for('egg#clusterClients');\n\n/**\n * Base on koa's Application\n * @see https://github.com/eggjs/egg-core\n * @see http://koajs.com/#application\n * @extends EggCore\n */\nclass EggApplication extends EggCore {\n\n  /**\n   * @constructor\n   * @param {Object} options\n   *  - {Object} [type] - type of instance, Agent and Application both extend koa, type can determine what it is.\n   *  - {String} [baseDir] - app root dir, default is `process.cwd()`\n   *  - {Object} [plugins] - custom plugin config, use it in unittest\n   */\n  constructor(options) {\n    super(options);\n\n    // export context base classes, let framework can impl sub class and over context extend easily.\n    this.ContextCookies = ContextCookies;\n    this.ContextLogger = ContextLogger;\n    this.ContextHttpClient = ContextHttpClient;\n\n    this.loader.loadConfig();\n\n    /**\n     * messenger instance\n     * @member {Messenger}\n     * @since 1.0.0\n     */\n    this.messenger = new Messenger();\n\n    // dump config after ready, ensure all the modifications during start will be recorded\n    this.ready(() => this.dumpConfig());\n    this._setupTimeoutTimer();\n\n    this.console.info('[egg:core] App root: %s', this.baseDir);\n    this.console.info('[egg:core] All *.log files save on %j', this.config.logger.dir);\n    this.console.info('[egg:core] Loaded enabled plugin %j', this.loader.orderPlugins);\n\n    // Listen the error that promise had not catch, then log it in common-error\n    this._unhandledRejectionHandler = this._unhandledRejectionHandler.bind(this);\n    process.on('unhandledRejection', this._unhandledRejectionHandler);\n\n    this[CLUSTER_CLIENTS] = [];\n\n    /**\n     * Wrap the Client with Leader/Follower Pattern\n     *\n     * @description almost the same as Agent.cluster API, the only different is that this method create Follower.\n     *\n     * @see https://github.com/node-modules/cluster-client\n     * @param {Function} clientClass - client class function\n     * @param {Object} [options]\n     *   - {Boolean} [autoGenerate] - whether generate delegate rule automatically, default is true\n     *   - {Function} [formatKey] - a method to tranform the subscription info into a string，default is JSON.stringify\n     *   - {Object} [transcode|JSON.stringify/parse]\n     *     - {Function} encode - custom serialize method\n     *     - {Function} decode - custom deserialize method\n     *   - {Boolean} [isBroadcast] - whether broadcast subscrption result to all followers or just one, default is true\n     *   - {Number} [responseTimeout] - response timeout, default is 3 seconds\n     *   - {Number} [maxWaitTime|30000] - leader startup max time, default is 30 seconds\n     * @return {ClientWrapper} wrapper\n     */\n    this.cluster = (clientClass, options) => {\n      options = options || {};\n      // cluster need a port that can't conflict on the environment\n      options.port = this._options.clusterPort;\n      // agent worker is leader, app workers are follower\n      options.isLeader = this.type === 'agent';\n      options.logger = this.coreLogger;\n      const client = cluster(clientClass, options);\n      this._patchClusterClient(client);\n      return client;\n    };\n\n    // register close function\n    this.beforeClose(() => {\n      for (const logger of this.loggers.values()) {\n        logger.close();\n      }\n      this.messenger.close();\n      process.removeListener('unhandledRejection', this._unhandledRejectionHandler);\n    });\n  }\n\n  /**\n   * print the infomation when console.log(app)\n   * @return {Object} inspected app.\n   * @since 1.0.0\n   * @example\n   * ```js\n   * console.log(app);\n   * =>\n   * {\n   *   name: 'mockapp',\n   *   env: 'test',\n   *   subdomainOffset: 2,\n   *   config: '<egg config>',\n   *   controller: '<egg controller>',\n   *   service: '<egg service>',\n   *   middlewares: '<egg middlewares>',\n   *   urllib: '<egg urllib>',\n   *   loggers: '<egg loggers>'\n   * }\n   * ```\n   */\n  inspect() {\n    const res = {\n      env: this.config.env,\n    };\n\n    function delegate(res, app, keys) {\n      for (const key of keys) {\n        /* istanbul ignore else */\n        if (app[key]) {\n          res[key] = app[key];\n        }\n      }\n    }\n\n    function abbr(res, app, keys) {\n      for (const key of keys) {\n        /* istanbul ignore else */\n        if (app[key]) {\n          res[key] = `<egg ${key}>`;\n        }\n      }\n    }\n\n    delegate(res, this, [\n      'name',\n      'baseDir',\n      'subdomainOffset',\n    ]);\n\n    abbr(res, this, [\n      'config',\n      'controller',\n      'serviceClasses',\n      'middlewares',\n      'httpclient',\n      'loggers',\n    ]);\n\n    return res;\n  }\n\n  toJSON() {\n    return this.inspect();\n  }\n\n  /**\n   * http request helper base on {@link httpclient}, it will auto save httpclient log.\n   * Keep the same api with `httpclient.request(url, args)`.\n   *\n   * See https://github.com/node-modules/urllib#api-doc for more details.\n   *\n   * @param {String} url request url address.\n   * @param {Object} opts\n   * - method {String} - Request method, defaults to GET. Could be GET, POST, DELETE or PUT. Alias 'type'.\n   * - data {Object} - Data to be sent. Will be stringify automatically.\n   * - dataType {String} - String - Type of response data. Could be `text` or `json`.\n   *   If it's `text`, the callbacked data would be a String.\n   *   If it's `json`, the data of callback would be a parsed JSON Object.\n   *   Default callbacked data would be a Buffer.\n   * - headers {Object} - Request headers.\n   * - timeout {Number} - Request timeout in milliseconds. Defaults to exports.TIMEOUT.\n   *   Include remote server connecting timeout and response timeout.\n   *   When timeout happen, will return ConnectionTimeout or ResponseTimeout.\n   * - auth {String} - `username:password` used in HTTP Basic Authorization.\n   * - followRedirect {Boolean} - follow HTTP 3xx responses as redirects. defaults to false.\n   * - gzip {Boolean} - let you get the res object when request connected, default false. alias customResponse\n   * @return {Object}\n   * - status {Number} - HTTP response status\n   * - headers {Object} - HTTP response seaders\n   * - res {Object} - HTTP response meta\n   * - data {Object} - HTTP response body\n   *\n   * @example\n   * ```js\n   * const result = yield app.curl('http://example.com/foo.json', {\n   *   method: 'GET',\n   *   dataType: 'json',\n   * });\n   * console.log(result.status, result.headers, result.data);\n   * ```\n   */\n  curl(url, opts) {\n    return this.httpclient.request(url, opts);\n  }\n\n  /**\n   * HttpClient instance\n   * @see https://github.com/node-modules/urllib\n   * @member {HttpClient}\n   */\n  get httpclient() {\n    if (!this[HTTPCLIENT]) {\n      this[HTTPCLIENT] = createHttpClient(this);\n    }\n    return this[HTTPCLIENT];\n  }\n\n  /**\n   *  All loggers contain logger, coreLogger and customLogger\n   * @member {Object}\n   * @since 1.0.0\n   */\n  get loggers() {\n    if (!this[LOGGERS]) {\n      this[LOGGERS] = createLoggers(this);\n    }\n    return this[LOGGERS];\n  }\n\n  /**\n   * Get logger by name, it's equal to app.loggers['name'],\n   * but you can extend it with your own logical.\n   * @param {String} name - logger name\n   * @return {Logger} logger\n   */\n  getLogger(name) {\n    return this.loggers[name] || null;\n  }\n\n  /**\n   * application logger, log file is `$HOME/logs/{appname}/{appname}-web`\n   * @member {Logger}\n   * @since 1.0.0\n   */\n  get logger() {\n    return this.getLogger('logger');\n  }\n\n  /**\n   * core logger for framework and plugins, log file is `$HOME/logs/{appname}/egg-web`\n   * @member {Logger}\n   * @since 1.0.0\n   */\n  get coreLogger() {\n    return this.getLogger('coreLogger');\n  }\n\n  _unhandledRejectionHandler(err) {\n    if (!(err instanceof Error)) {\n      const newError = new Error(String(err));\n      // err maybe an object, try to copy the name, message and stack to the new error instance\n      /* istanbul ignore else */\n      if (err) {\n        if (err.name) newError.name = err.name;\n        if (err.message) newError.message = err.message;\n        if (err.stack) newError.stack = err.stack;\n      }\n      err = newError;\n    }\n    /* istanbul ignore else */\n    if (err.name === 'Error') {\n      err.name = 'unhandledRejectionError';\n    }\n    this.coreLogger.error(err);\n  }\n\n  /**\n   * save app.config to `run/${type}_config.json`\n   * @private\n   */\n  dumpConfig() {\n    const rundir = this.config.rundir;\n    let ignoreList;\n    try {\n      // support array and set\n      ignoreList = Array.from(this.config.dump.ignore);\n    } catch (_) {\n      ignoreList = [];\n    }\n    const dumpFile = path.join(rundir, `${this.type}_config.json`);\n    try {\n      /* istanbul ignore if */\n      if (!fs.existsSync(rundir)) fs.mkdirSync(rundir);\n      const json = extend(true, {}, { config: this.config, plugins: this.plugins });\n      utils.convertObject(json, ignoreList);\n      fs.writeFileSync(dumpFile, JSON.stringify(json, null, 2));\n    } catch (err) {\n      this.coreLogger.warn(`dumpConfig error: ${err.message}`);\n    }\n  }\n\n  get [EGG_PATH]() {\n    return path.join(__dirname, '..');\n  }\n\n  _setupTimeoutTimer() {\n    const startTimeoutTimer = setTimeout(() => {\n      this.coreLogger.error(`${this.type} still doesn't ready after ${this.config.workerStartTimeout} ms.`);\n      this.emit('startTimeout');\n    }, this.config.workerStartTimeout);\n    this.ready(() => clearTimeout(startTimeoutTimer));\n  }\n\n  /**\n   * app.env delegate app.config.env\n   * @deprecated\n   */\n  get env() {\n    this.deprecate('please use app.config.env instead');\n    return this.config.env;\n  }\n  /* eslint no-empty-function: off */\n  set env(_) {}\n\n  /**\n   * app.proxy delegate app.config.proxy\n   * @deprecated\n   */\n  get proxy() {\n    this.deprecate('please use app.config.proxy instead');\n    return this.config.proxy;\n  }\n  /* eslint no-empty-function: off */\n  set proxy(_) {}\n\n  /**\n   * create a singleton instance\n   * @param {String} name - unique name for singleton\n   * @param {Object} create - method will be invoked when singleton instance create\n   */\n  addSingleton(name, create) {\n    const options = {};\n    options.name = name;\n    options.create = create;\n    options.app = this;\n    const singleton = new Singleton(options);\n    singleton.init();\n  }\n\n  _patchClusterClient(client) {\n    const create = client.create;\n    client.create = (...args) => {\n      const realClient = create.apply(client, args);\n      this[CLUSTER_CLIENTS].push(realClient);\n\n      this.beforeClose(function* () {\n        yield cluster.close(realClient);\n      });\n\n      return realClient;\n    };\n  }\n}\n\nmodule.exports = EggApplication;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/index.js":"'use strict';\n\nconst EggCore = require('./lib/egg');\nconst EggLoader = require('./lib/loader/egg_loader');\nconst BaseContextClass = require('./lib/utils/base_context_class');\n\nmodule.exports = {\n  EggCore,\n  EggLoader,\n  BaseContextClass,\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/egg.js":"'use strict';\n\nconst assert = require('assert');\nconst fs = require('fs');\nconst KoaApplication = require('koa');\nconst EggConsoleLogger = require('egg-logger').EggConsoleLogger;\nconst debug = require('debug')('egg-core');\nconst is = require('is-type-of');\nconst co = require('co');\nconst BaseContextClass = require('./utils/base_context_class');\nconst utils = require('./utils');\nconst Router = require('./utils/router');\n\n\nconst DEPRECATE = Symbol('EggCore#deprecate');\nconst CLOSESET = Symbol('EggCore#closeSet');\nconst ISCLOSE = Symbol('EggCore#isClose');\nconst CLOSE_PROMISE = Symbol('EggCore#closePromise');\nconst ROUTER = Symbol('EggCore#router');\nconst EGG_LOADER = Symbol.for('egg#loader');\n\nclass EggCore extends KoaApplication {\n\n  /**\n   * @constructor\n   * @param {Object} options - options\n   * @param {String} [options.baseDir=process.cwd()] - the directory of application\n   * @param {String} [options.type=application|agent] - wheter it's running in app worker or agent worker\n   * @param {Object} [options.plugins] - custom plugins\n   * @since 1.0.0\n   */\n  constructor(options) {\n    options = options || {};\n    options.baseDir = options.baseDir || process.cwd();\n    options.type = options.type || 'application';\n\n    assert(typeof options.baseDir === 'string', 'options.baseDir required, and must be a string');\n    assert(fs.existsSync(options.baseDir), `Directory ${options.baseDir} not exists`);\n    assert(fs.statSync(options.baseDir).isDirectory(), `Directory ${options.baseDir} is not a directory`);\n    assert(options.type === 'application' || options.type === 'agent', 'options.type should be application or agent');\n\n    super();\n\n    /**\n     * @member {Object} EggCore#_options\n     * @private\n     * @since 1.0.0\n     */\n    this._options = options;\n\n    /**\n     * logging for EggCore, avoid using console directly\n     * @member {Logger} EggCore#console\n     * @private\n     * @since 1.0.0\n     */\n    this.console = new EggConsoleLogger();\n\n    // register a close set\n    this[CLOSESET] = new Set();\n    // cache deprecate object by file\n    this[DEPRECATE] = new Map();\n\n    /**\n     * @member {BaseContextClass} EggCore#BaseContextClass\n     * @since 1.0.0\n     */\n    this.BaseContextClass = BaseContextClass;\n\n\n    /**\n     * Base controller to be extended by controller in `app.controller`\n     * @class Controller\n     * @extends BaseContextClass\n     * @example\n     * class UserController extends app.Controller {}\n     */\n    const Controller = this.BaseContextClass;\n\n    /**\n     * Retreive base controller\n     * @member {Controller} EggCore#Controller\n     * @since 1.0.0\n     */\n    this.Controller = Controller;\n\n    /**\n     * Base service to be extended by services in `app.service`\n     * @class Service\n     * @extends BaseContextClass\n     * @example\n     * class UserService extends app.Service {}\n     */\n    const Service = this.BaseContextClass;\n\n    /**\n     * Retreive base service\n     * @member {Service} EggCore#Service\n     * @since 1.0.0\n     */\n    this.Service = Service;\n\n    /**\n     * The loader instance, the default class is {@link EggLoader}.\n     * If you want define\n     * @member {EggLoader} EggCore#loader\n     * @since 1.0.0\n     */\n    const Loader = this[EGG_LOADER];\n    assert(Loader, 'Symbol.for(\\'egg#loader\\') is required');\n    this.loader = new Loader({\n      baseDir: options.baseDir,\n      app: this,\n      plugins: options.plugins,\n      logger: this.console,\n    });\n\n    this._initReady();\n  }\n\n  /**\n   * override koa's app.use, support async function\n   * @param {Function} fn - middleware\n   * @return {Application} app\n   * @since 1.0.0\n   */\n  use(fn) {\n    assert(is.function(fn), 'app.use() requires a function');\n    debug('use %s', fn._name || fn.name || '-');\n    this.middleware.push(utils.middleware(fn));\n    return this;\n  }\n\n  /**\n   * Whether `application` or `agent`\n   * @member {String}\n   * @since 1.0.0\n   */\n  get type() {\n    return this._options.type;\n  }\n\n  /**\n   * The current directory of application\n   * @member {String}\n   * @see {@link AppInfo#baseDir}\n   * @since 1.0.0\n   */\n  get baseDir() {\n    return this._options.baseDir;\n  }\n\n  /**\n   * Alias to {@link https://npmjs.com/package/depd}\n   * @member {Function}\n   * @since 1.0.0\n   */\n  get deprecate() {\n    const caller = utils.getCalleeFromStack();\n    if (!this[DEPRECATE].has(caller)) {\n      const deprecate = require('depd')('egg');\n      // dynamic set _file to caller\n      deprecate._file = caller;\n      this[DEPRECATE].set(caller, deprecate);\n    }\n    return this[DEPRECATE].get(caller);\n  }\n\n  /**\n   * The name of application\n   * @member {String}\n   * @see {@link AppInfo#name}\n   * @since 1.0.0\n   */\n  get name() {\n    return this.loader.pkg.name;\n  }\n\n  /**\n   * Retreive enabled plugins\n   * @member {Object}\n   * @since 1.0.0\n   */\n  get plugins() {\n    return this.loader.plugins;\n  }\n\n  /**\n   * The configuration of application\n   * @member {Config}\n   * @since 1.0.0\n   */\n  get config() {\n    return this.loader.config;\n  }\n\n  /**\n   * Excute scope after loaded and before app start\n   *\n   * @param  {Function|GeneratorFunction|AsyncFunction} scope function will excute before app start\n   */\n  beforeStart(scope) {\n    if (!is.function(scope)) {\n      throw new Error('beforeStart only support function');\n    }\n\n    // get filename from stack\n    const name = utils.getCalleeFromStack(true);\n    const done = this.readyCallback(name);\n\n    // ensure scope excutes after load completed\n    process.nextTick(() => {\n      co(function* () {\n        yield utils.callFn(scope);\n      }).then(() => done(), done);\n    });\n  }\n\n  /**\n   * Close all, it wil close\n   * - callbacks registered by beforeClose\n   * - emit `close` event\n   * - remove add listeners\n   *\n   * If error is thrown when it's closing, the promise will reject.\n   * It will also reject after following call.\n   * @return {Promise} promise\n   * @since 1.0.0\n   */\n  close() {\n    if (this[CLOSE_PROMISE]) return this[CLOSE_PROMISE];\n\n    this[CLOSE_PROMISE] = co(function* closeFunction() {\n      // close in reverse order: first created, last closed\n      const closeFns = Array.from(this[CLOSESET]);\n      for (const fn of closeFns.reverse()) {\n        yield utils.callFn(fn);\n        this[CLOSESET].delete(fn);\n      }\n\n      // Be called after other close callbacks\n      this.emit('close');\n      this.removeAllListeners();\n      this[ISCLOSE] = true;\n    }.bind(this));\n    return this[CLOSE_PROMISE];\n  }\n\n  /**\n   * Register a function that will be called when app close\n   * @param {Function} fn - the function that can be generator function or async function\n   */\n  beforeClose(fn) {\n    assert(is.function(fn), 'argument should be function');\n    this[CLOSESET].add(fn);\n  }\n\n  /**\n   * @member {Function}\n   * @private\n   */\n  _initReady() {\n    /**\n     * register an callback function that will be invoked when application is ready.\n     * @method {Function} EggCore#ready\n     * @see https://github.com/node-modules/ready\n     * @since 1.0.0\n     * @example\n     * const app = new Application(...);\n     * app.ready(err => {\n     *   if (err) throw err;\n     *   console.log('done');\n     * });\n     */\n\n    /**\n     * If a client starts asynchronously, you can register `readyCallback`,\n     * then the application will wait for the callback to ready\n     *\n     * It will log when the callback is not invoked after 10s\n     *\n     * Recommend to use {@link EggCore#beforeStart}\n     * @method {Function} EggCore#readyCallback\n     * @since 1.0.0\n     * @example\n     * const done = app.readyCallback('mysql');\n     * mysql.ready(done);\n     */\n    require('ready-callback')({ timeout: 10000 }).mixin(this);\n\n    this.on('ready_stat', data => {\n      this.console.info('[egg:core:ready_stat] end ready task %s, remain %j', data.id, data.remain);\n    }).on('ready_timeout', id => {\n      this.console.warn('[egg:core:ready_timeout] 10 seconds later %s was still unable to finish.', id);\n    });\n\n    this.ready(() => debug('egg emit ready, application started'));\n  }\n\n  /**\n   * get router\n   * @member {Router} EggCore#router\n   * @since 1.0.0\n   */\n  get router() {\n    if (this[ROUTER]) {\n      return this[ROUTER];\n    }\n    const router = this[ROUTER] = new Router({ sensitive: true }, this);\n    // register router middleware\n    this.use(router.middleware());\n    return router;\n  }\n\n  /**\n   * Alias to {@link Router#url}\n   * @param {String} name - Router name\n   * @param {Object} params - more parameters\n   * @return {String} url\n   */\n  url(name, params) {\n    return this.router.url(name, params);\n  }\n\n  del(...args) {\n    this.router.delete(...args);\n    return this;\n  }\n\n  get [EGG_LOADER]() {\n    return require('./loader/egg_loader');\n  }\n}\n\n// delegate all router method to application\nutils.methods.concat([ 'all', 'resources', 'register', 'redirect' ]).forEach(method => {\n  EggCore.prototype[method] = function(...args) {\n    this.router[method](...args);\n    return this;\n  };\n});\n\nmodule.exports = EggCore;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/utils/base_context_class.js":"'use strict';\n\n/**\n * BaseContextClass is a base class that can be extended,\n * it's instantiated in context level,\n * {@link Helper}, {@link Service} is extending it.\n */\nclass BaseContextClass {\n\n  /**\n   * @constructor\n   * @param {Context} ctx - context instance\n   * @since 1.0.0\n   */\n  constructor(ctx) {\n    /**\n     * @member {Context} BaseContextClass#ctx\n     * @since 1.0.0\n     */\n    this.ctx = ctx;\n    /**\n     * @member {Application} BaseContextClass#app\n     * @since 1.0.0\n     */\n    this.app = ctx.app;\n    /**\n     * @member {Config} BaseContextClass#config\n     * @since 1.0.0\n     */\n    this.config = ctx.app.config;\n    /**\n     * @member {Service} BaseContextClass#service\n     * @since 1.0.0\n     */\n    this.service = ctx.service;\n  }\n}\n\nmodule.exports = BaseContextClass;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/utils/index.js":"'use strict';\n\nconst co = require('co');\nconst homedir = require('node-homedir');\nconst is = require('is-type-of');\n\n\nmodule.exports = {\n\n  loadFile(filepath) {\n    try {\n      const obj = require(filepath);\n      if (!obj) return obj;\n      // it's es module\n      if (obj.__esModule) return 'default' in obj ? obj.default : obj;\n      return obj;\n    } catch (err) {\n      err.message = '[egg-core] load file: ' + filepath + ', error: ' + err.message;\n      throw err;\n    }\n  },\n\n  existsModule(filepath) {\n    try {\n      require.resolve(filepath);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  },\n\n  getHomedir() {\n    // EGG_HOME for test\n    return process.env.EGG_HOME || homedir() || '/home/admin';\n  },\n\n  methods: [ 'head', 'options', 'get', 'put', 'patch', 'post', 'delete' ],\n\n  * callFn(fn, args) {\n    args = args || [];\n    if (!is.function(fn)) return;\n    if (is.generatorFunction(fn)) {\n      return yield fn(...args);\n    }\n    const r = fn(...args);\n    if (is.promise(r)) {\n      return yield r;\n    }\n    return r;\n  },\n\n  middleware(fn) {\n    if (is.generatorFunction(fn)) return fn;\n\n    // support async function\n    return function* (next) {\n      // next is a generator\n      yield module.exports.callFn(fn, [ this, () => co(next) ]);\n    };\n  },\n\n  getCalleeFromStack(withLine) {\n    const limit = Error.stackTraceLimit;\n    const prep = Error.prepareStackTrace;\n\n    Error.prepareStackTrace = prepareObjectStackTrace;\n    Error.stackTraceLimit = 4;\n\n    // capture the stack\n    const obj = {};\n    Error.captureStackTrace(obj);\n    let callSite = obj.stack[2];\n    /* istanbul ignore next */\n    if (callSite) {\n      // egg-mock will create a proxy\n      // https://github.com/eggjs/egg-mock/blob/master/lib/app.js#L167\n      const filename = callSite.getFileName() || '';\n      if (filename.endsWith('egg-mock/lib/app.js')) callSite = obj.stack[3];\n    }\n\n    Error.prepareStackTrace = prep;\n    Error.stackTraceLimit = limit;\n\n    /* istanbul ignore next */\n    if (!callSite) return '<anonymous>';\n    const fileName = callSite.getFileName();\n    if (!withLine || !fileName) return fileName || '<anonymous>';\n    return `${fileName}:${callSite.getLineNumber()}:${callSite.getColumnNumber()}`;\n  },\n};\n\n\n/**\n * Capture call site stack from v8.\n * https://github.com/v8/v8/wiki/Stack-Trace-API\n */\n\nfunction prepareObjectStackTrace(obj, stack) {\n  return stack;\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/utils/router.js":"'use strict';\n\nconst is = require('is-type-of');\nconst KoaRouter = require('koa-router');\nconst utility = require('utility');\nconst inflection = require('inflection');\nconst assert = require('assert');\nconst methods = require('./index').methods;\nconst utils = require('./index');\n\nconst REST_MAP = {\n  index: {\n    suffix: '',\n    method: 'GET',\n  },\n  new: {\n    namePrefix: 'new_',\n    member: true,\n    suffix: 'new',\n    method: 'GET',\n  },\n  create: {\n    suffix: '',\n    method: 'POST',\n  },\n  show: {\n    member: true,\n    suffix: ':id',\n    method: 'GET',\n  },\n  edit: {\n    member: true,\n    namePrefix: 'edit_',\n    suffix: ':id/edit',\n    method: 'GET',\n  },\n  update: {\n    member: true,\n    namePrefix: '',\n    suffix: ':id',\n    method: 'PUT',\n  },\n  destroy: {\n    member: true,\n    namePrefix: 'destroy_',\n    suffix: ':id',\n    method: 'DELETE',\n  },\n};\n\n/**\n * Extend {@link https://github.com/alexmingoia/koa-router}\n */\nclass Router extends KoaRouter {\n\n  /**\n   * @constructor\n   * @param {Object} opts - Router options.\n   * @param {Application} app - Application object.\n   */\n  constructor(opts, app) {\n    super(opts);\n    this.app = app;\n    // patch koa-router@5.x\n    this.patchRouterMethod();\n  }\n\n  patchRouterMethod() {\n    // patch router methods to support async function middleware and string controller\n    methods.concat([ 'all' ]).forEach(method => {\n      this[method] = (...args) => {\n        const splited = splitedRouterParams(args);\n        args = splited.prefix.concat(convertMiddlewares(splited.middlewares, this.app));\n        return super[method](...args);\n      };\n    });\n  }\n\n  /**\n   * Create and register a route.\n   * @param {String} path - url path\n   * @param {Array} methods - Array of HTTP verbs\n   * @param {Array} middlewares -\n   * @param {Object} opts -\n   * @return {Route} this\n   */\n  register(path, methods, middlewares, opts) {\n    // patch register to support async function middleware and string controller\n    middlewares = Array.isArray(middlewares) ? middlewares : [ middlewares ];\n    middlewares = convertMiddlewares(middlewares, this.app);\n    return super.register(path, methods, middlewares, opts);\n  }\n\n  /**\n   * restful router api\n   * @param {String} name - Router name\n   * @param {String} prefix - url prefix\n   * @param {Function} middleware - middleware or controller\n   * @example\n   * ```js\n   * app.resources('/posts', 'posts')\n   * app.resources('posts', '/posts', 'posts')\n   * app.resources('posts', '/posts', app.role.can('user'), app.controller.posts)\n   * ```\n   *\n   * Examples:\n   *\n   * ```js\n   * app.resources('/posts', 'posts')\n   * ```\n   *\n   * yield router mapping\n   *\n   * Method | Path            | Route Name     | Controller.Action\n   * -------|-----------------|----------------|-----------------------------\n   * GET    | /posts          | posts          | app.controller.posts.index\n   * GET    | /posts/new      | new_post       | app.controller.posts.new\n   * GET    | /posts/:id      | post           | app.controller.posts.show\n   * GET    | /posts/:id/edit | edit_post      | app.controller.posts.edit\n   * POST   | /posts          | posts          | app.controller.posts.create\n   * PUT    | /posts/:id      | post           | app.controller.posts.update\n   * DELETE | /posts/:id      | post           | app.controller.posts.destroy\n   *\n   * app.router.url can generate url based on arguments\n   * ```js\n   * app.router.url('posts')\n   * => /posts\n   * app.router.url('post', { id: 1 })\n   * => /posts/1\n   * app.router.url('new_post')\n   * => /posts/new\n   * app.router.url('edit_post', { id: 1 })\n   * => /posts/1/edit\n   * ```\n   * @return {Router} return route object.\n   * @since 1.0.0\n   */\n  resources(...args) {\n    const splited = splitedRouterParams(args);\n    const middleware = convertMiddlewares(splited.middlewares, this.app);\n\n    let name = '';\n    let prefix = '';\n    if (splited.prefix.length === 2) {\n      // router.get('users', '/users')\n      name = splited.prefix[0];\n      prefix = splited.prefix[1];\n    } else {\n      // router.get('/users')\n      prefix = splited.prefix[0];\n    }\n\n    // last argument is Controller object\n    const controller = middleware.pop();\n\n    for (const key in REST_MAP) {\n      const action = controller[key];\n      if (!action) continue;\n\n      const opts = REST_MAP[key];\n      let formatedName;\n      if (opts.member) {\n        formatedName = inflection.singularize(name);\n      } else {\n        formatedName = inflection.pluralize(name);\n      }\n      if (opts.namePrefix) {\n        formatedName = opts.namePrefix + formatedName;\n      }\n      prefix = prefix.replace(/\\/$/, '');\n      const path = opts.suffix ? `${prefix}/${opts.suffix}` : prefix;\n      this.register(path, [ opts.method ], middleware.concat(action), { name: formatedName });\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {String} name - Router name\n   * @param {Object} params - more parameters\n   * @example\n   * ```js\n   * router.url('edit_post', { id: 1, name: 'foo', page: 2 })\n   * => /posts/1/edit?name=foo&page=2\n   * router.url('posts', { name: 'foo&1', page: 2 })\n   * => /posts?name=foo%261&page=2\n   * ```\n   * @return {String} url by path name and query params.\n   * @since 1.0.0\n   */\n  url(name, params) {\n    const route = this.route(name);\n    if (!route) return '';\n\n    const args = params;\n    let url = route.path;\n\n    assert(!is.regExp(url), `Can't get the url for regExp ${url} for by name '${name}'`);\n\n    const queries = [];\n    if (typeof args === 'object' && args !== null) {\n      const replacedParams = [];\n      url = url.replace(/:([a-zA-Z_]\\w*)/g, function($0, key) {\n        if (utility.has(args, key)) {\n          const values = args[key];\n          replacedParams.push(key);\n          return utility.encodeURIComponent(Array.isArray(values) ? values[0] : values);\n        }\n        return $0;\n      });\n\n      for (const key in args) {\n        if (replacedParams.indexOf(key) !== -1) {\n          continue;\n        }\n\n        const values = args[key];\n        const encodedKey = utility.encodeURIComponent(key);\n        if (Array.isArray(values)) {\n          for (const val of values) {\n            queries.push(`${encodedKey}=${utility.encodeURIComponent(val)}`);\n          }\n        } else {\n          queries.push(`${encodedKey}=${utility.encodeURIComponent(values)}`);\n        }\n      }\n    }\n\n    if (queries.length > 0) {\n      const queryStr = queries.join('&');\n      if (url.indexOf('?') === -1) {\n        url = `${url}?${queryStr}`;\n      } else {\n        url = `${url}&${queryStr}`;\n      }\n    }\n\n    return url;\n  }\n\n  pathFor(name, params) {\n    return this.url(name, params);\n  }\n}\n\n/**\n * split (name, url, ...middleware, controller) to\n * {\n *   prefix: [name, url]\n *   middlewares [...middleware, controller]\n * }\n *\n * @param  {Array} args router params\n * @return {Object} prefix and middlewares\n */\nfunction splitedRouterParams(args) {\n  let prefix;\n  let middlewares;\n  if (args.length >= 3 && (is.string(args[1]) || is.regExp(args[1]))) {\n    // app.get(name, url, [...middleware], controller)\n    prefix = args.slice(0, 2);\n    middlewares = args.slice(2);\n  } else {\n    // app.get(url, [...middleware], controller)\n    prefix = args.slice(0, 1);\n    middlewares = args.slice(1);\n  }\n  return { prefix, middlewares };\n}\n\n/**\n * 1. make controller(last argument) support string\n * - [url, controller]: app.get('/home', 'home');\n * - [name, url, controller(string)]: app.get('posts', '/posts', 'posts.list');\n * - [name, url, controller]: app.get('posts', '/posts', app.controller.posts.list);\n * - [name, url(regexp), controller]: app.get('regRouter', /\\/home\\/index/, 'home.index');\n * - [name, url, middleware, [...], controller]: `app.get(/user/:id', hasLogin, canGetUser, 'user.show');`\n *\n * 2. make middleware support async function\n *\n * @param  {Array} middlewares middlewares and controller(last middleware)\n * @param  {Application} app  egg application instance\n * @return {Array} middlewares\n */\nfunction convertMiddlewares(middlewares, app) {\n  let controller = middlewares.pop();\n\n  // make middleware support async function\n  middlewares = middlewares.map(utils.middleware);\n\n  // make controller(last argument) support string\n  if (is.string(controller)) {\n    const actions = controller.split('.');\n    let obj = app.controller;\n    actions.forEach(key => {\n      obj = obj[key];\n      if (!obj) throw new Error(`controller '${controller}' not exists`);\n    });\n    controller = obj;\n  }\n  return middlewares.concat([ controller ]);\n}\n\nmodule.exports = Router;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/loader/egg_loader.js":"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst assert = require('assert');\nconst isFunction = require('is-type-of').function;\nconst debug = require('debug')('egg-core');\nconst FileLoader = require('./file_loader');\nconst ContextLoader = require('./context_loader');\nconst utils = require('../utils');\n\n\nclass EggLoader {\n\n  /**\n   * @constructor\n   * @param {Object} options - options\n   * @param {String} options.baseDir - the directory of application\n   * @param {EggCore} options.app - Application instance\n   * @param {Logger} options.logger - logger\n   * @param {Object} [options.plugins] - custom plugins\n   * @since 1.0.0\n   */\n  constructor(options) {\n    this.options = options;\n    assert(fs.existsSync(this.options.baseDir), `${this.options.baseDir} not exists`);\n    assert(this.options.app, 'options.app is required');\n    assert(this.options.logger, 'options.logger is required');\n    debug('EggLoader options %j', options);\n\n    this.app = this.options.app;\n\n    /**\n     * @member {Object} EggLoader#pkg\n     * @see {@link AppInfo#pkg}\n     * @since 1.0.0\n     */\n    this.pkg = require(path.join(this.options.baseDir, 'package.json'));\n\n    /**\n     * All framework directories.\n     *\n     * You can extend Application of egg, the entrypoint is options.app,\n     *\n     * loader will find all directories from the prototype of Application,\n     * you should define `Symbol.for('egg#eggPath')` property.\n     *\n     * ```\n     * // lib/example.js\n     * const egg = require('egg');\n     * class ExampleApplication extends egg.Application {\n     *   constructor(options) {\n     *     super(options);\n     *   }\n     *\n     *   get [Symbol.for('egg#eggPath')]() {\n     *     return path.join(__dirname, '..');\n     *   }\n     * }\n     * ```\n     * @member {Array} EggLoader#eggPaths\n     * @see EggLoader#getEggPaths\n     * @since 1.0.0\n     */\n    this.eggPaths = this.getEggPaths();\n    debug('Loaded eggPaths %j', this.eggPaths);\n\n    /**\n     * @member {String} EggLoader#serverEnv\n     * @see AppInfo#env\n     * @since 1.0.0\n     */\n    this.serverEnv = this.getServerEnv();\n    debug('Loaded serverEnv %j', this.serverEnv);\n\n    /**\n     * @member {AppInfo} EggLoader#appInfo\n     * @since 1.0.0\n     */\n    this.appInfo = this.getAppInfo();\n  }\n\n  /**\n   * Get {@link AppInfo#env}\n   * @return {String} env\n   * @see AppInfo#env\n   * @private\n   * @since 1.0.0\n   */\n  getServerEnv() {\n    let serverEnv;\n\n    const envPath = path.join(this.options.baseDir, 'config/env');\n    if (fs.existsSync(envPath)) {\n      serverEnv = fs.readFileSync(envPath, 'utf8').trim();\n    }\n\n    if (!serverEnv) {\n      serverEnv = process.env.EGG_SERVER_ENV;\n    }\n\n    if (!serverEnv) {\n      if (process.env.NODE_ENV === 'test') {\n        serverEnv = 'unittest';\n      } else if (process.env.NODE_ENV === 'production') {\n        serverEnv = 'prod';\n      } else {\n        serverEnv = 'local';\n      }\n    }\n\n    return serverEnv;\n  }\n\n  /**\n   * Get {@link AppInfo#name}\n   * @return {String} appname\n   * @private\n   * @since 1.0.0\n   */\n  getAppname() {\n    if (this.pkg.name) {\n      debug('Loaded appname(%s) from package.json', this.pkg.name);\n      return this.pkg.name;\n    }\n    const pkg = path.join(this.options.baseDir, 'package.json');\n    throw new Error(`name is required from ${pkg}`);\n  }\n\n  /**\n   * Get app info\n   * @return {AppInfo} appInfo\n   * @since 1.0.0\n   */\n  getAppInfo() {\n    const env = this.serverEnv;\n    const home = utils.getHomedir();\n    const baseDir = this.options.baseDir;\n\n    /**\n     * Meta infomation of the application\n     * @class AppInfo\n     */\n    return {\n      /**\n       * The name of the application, retreive from the name property in `package.json`.\n       * @member {String} AppInfo#name\n       */\n      name: this.getAppname(),\n\n      /**\n       * The current directory, where the application code is.\n       * @member {String} AppInfo#baseDir\n       */\n      baseDir,\n\n      /**\n       * The environment of the application, **it's not NODE_ENV**\n       *\n       * 1. from `$baseDir/config/env`\n       * 2. from EGG_SERVER_ENV\n       * 3. from NODE_ENV\n       *\n       * env | description\n       * ---       | ---\n       * test      | system integration testing\n       * prod      | production\n       * local     | local on your own computer\n       * unittest  | unit test\n       *\n       * @member {String} AppInfo#env\n       * @see https://eggjs.org/zh-cn/basics/env.html\n       */\n      env,\n\n      /**\n       * The use directory, same as `process.env.HOME`\n       * @member {String} AppInfo#HOME\n       */\n      HOME: home,\n\n      /**\n       * parsed from `package.json`\n       * @member {Object} AppInfo#pkg\n       */\n      pkg: this.pkg,\n\n      /**\n       * The directory whether is baseDir or HOME depend on env.\n       * it's good for test when you want to write some file to HOME,\n       * but don't want to write to the real directory,\n       * so use root to write file to baseDir instead of HOME when unitest.\n       * keep root directory in baseDir when local and unittest\n       * @member {String} AppInfo#root\n       */\n      root: env === 'local' || env === 'unittest' ? baseDir : home,\n    };\n  }\n\n  /**\n   * Get {@link EggLoader#eggPaths}\n   * @return {Array} framework directories\n   * @see {@link EggLoader#eggPaths}\n   * @private\n   * @since 1.0.0\n   */\n  getEggPaths() {\n    // avoid require recursively\n    const EggCore = require('../egg');\n    const eggPaths = [];\n\n    let proto = this.app;\n\n    // Loop for the prototype chain\n    while (proto) {\n      proto = Object.getPrototypeOf(proto);\n      // stop the loop if\n      // - object extends Object\n      // - object extends EggCore\n      if (proto === Object.prototype || proto === EggCore.prototype) {\n        break;\n      }\n\n      assert(proto.hasOwnProperty(Symbol.for('egg#eggPath')), 'Symbol.for(\\'egg#eggPath\\') is required on Application');\n      const eggPath = proto[Symbol.for('egg#eggPath')];\n      assert(eggPath && typeof eggPath === 'string', 'Symbol.for(\\'egg#eggPath\\') should be string');\n      const realpath = fs.realpathSync(eggPath);\n      if (eggPaths.indexOf(realpath) === -1) {\n        eggPaths.unshift(realpath);\n      }\n    }\n\n    return eggPaths;\n  }\n\n  // Low Level API\n\n  /**\n   * Load single file, will invork when export is function\n   *\n   * @param {String} filepath - fullpath\n   * @param {Array} arguments - pass rest arguments into the function when invork\n   * @return {Object} exports\n   * @example\n   * ```js\n   * app.loader.loadFile(path.join(app.options.baseDir, 'config/router.js'));\n   * ```\n   * @since 1.0.0\n   */\n  loadFile(filepath) {\n    if (!fs.existsSync(filepath)) {\n      return null;\n    }\n\n    const ret = utils.loadFile(filepath);\n    // function(arg1, args, ...) {}\n    let inject = Array.prototype.slice.call(arguments, 1);\n    if (inject.length === 0) inject = [ this.app ];\n    return isFunction(ret) ? ret.apply(null, inject) : ret;\n  }\n\n  /**\n   * Get all loadUnit\n   *\n   * loadUnit is a directory that can be loaded by EggLoader, it has the same structure.\n   * loadUnit has a path and a type(app, framework, plugin).\n   *\n   * The order of the loadUnits:\n   *\n   * 1. plugin\n   * 2. framework\n   * 3. app\n   *\n   * @return {Array} loadUnits\n   * @since 1.0.0\n   */\n  getLoadUnits() {\n    if (this.dirs) {\n      return this.dirs;\n    }\n\n    const dirs = this.dirs = [];\n\n    if (this.orderPlugins) {\n      for (const plugin of this.orderPlugins) {\n        dirs.push({\n          path: plugin.path,\n          type: 'plugin',\n        });\n      }\n    }\n\n    // framework or egg path\n    for (const eggPath of this.eggPaths) {\n      dirs.push({\n        path: eggPath,\n        type: 'framework',\n      });\n    }\n\n    // application\n    dirs.push({\n      path: this.options.baseDir,\n      type: 'app',\n    });\n\n    debug('Loaded dirs %j', dirs);\n    return dirs;\n  }\n\n  /**\n   * Load files using {@link FileLoader}, inject to {@link Application}\n   * @param {String|Array} directory - see {@link FileLoader}\n   * @param {String} property - see {@link FileLoader}\n   * @param {Object} opt - see {@link FileLoader}\n   * @since 1.0.0\n   */\n  loadToApp(directory, property, opt) {\n    const target = this.app[property] = {};\n    opt = Object.assign({}, {\n      directory,\n      target,\n      inject: this.app,\n    }, opt);\n    new FileLoader(opt).load();\n  }\n\n  /**\n   * Load files using {@link ContextLoader}\n   * @param {String|Array} directory - see {@link ContextLoader}\n   * @param {String} property - see {@link ContextLoader}\n   * @param {Object} opt - see {@link ContextLoader}\n   * @since 1.0.0\n   */\n  loadToContext(directory, property, opt) {\n    opt = Object.assign({}, {\n      directory,\n      property,\n      inject: this.app,\n    }, opt);\n    new ContextLoader(opt).load();\n  }\n\n  /**\n   * @member {FileLoader} EggLoader#FileLoader\n   * @since 1.0.0\n   */\n  get FileLoader() {\n    return FileLoader;\n  }\n\n  /**\n   * @member {ContextLoader} EggLoader#ContextLoader\n   * @since 1.0.0\n   */\n  get ContextLoader() {\n    return ContextLoader;\n  }\n\n}\n\n/**\n * Mixin methods to EggLoader\n * // ES6 Multiple Inheritance\n * https://medium.com/@leocavalcante/es6-multiple-inheritance-73a3c66d2b6b\n */\nconst loaders = [\n  require('./mixin/plugin'),\n  require('./mixin/config'),\n  require('./mixin/extend'),\n  require('./mixin/custom'),\n  require('./mixin/service'),\n  require('./mixin/middleware'),\n  require('./mixin/controller'),\n  require('./mixin/router'),\n];\n\nfor (const loader of loaders) {\n  Object.assign(EggLoader.prototype, loader);\n}\n\nmodule.exports = EggLoader;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/loader/file_loader.js":"'use strict';\n\nconst assert = require('assert');\nconst fs = require('fs');\nconst debug = require('debug')('egg-core:loader');\nconst path = require('path');\nconst globby = require('globby');\nconst is = require('is-type-of');\nconst deprecate = require('depd')('egg');\nconst utils = require('../utils');\nconst FULLPATH = Symbol('EGG_LOADER_ITEM_FULLPATH');\nconst EXPORTS = Symbol('EGG_LOADER_ITEM_EXPORTS');\n\nconst defaults = {\n  directory: null,\n  target: null,\n  ignore: undefined,\n  lowercaseFirst: false,\n  caseStyle: 'camel',\n  initializer: null,\n  call: true,\n  override: false,\n  inject: undefined,\n};\n\n/**\n * Load files from directory to target object.\n * @since 1.0.0\n */\nclass FileLoader {\n\n  /**\n   * @constructor\n   * @param {Object} options - options\n   * @param {String|Array} options.directory - directories to be loaded\n   * @param {Object} options.target - attach the target object from loaded files\n   * @param {String} options.ignore - ignore the files when load, support glob\n   * @param {Function} options.initializer - custom file exports, receive two parameters, first is the inject object, second is an `options` object that contain `path`\n   * @param {Boolean} options.call - determine whether invoke when exports is function\n   * @param {Boolean} options.override - determine whether override the property when get the same name\n   * @param {Object} options.inject - an object that be the argument when invoke the function\n   * @param {String|Function} options.caseStyle - set property's case when converting a filepath to property list.\n   */\n  constructor(options) {\n    assert(options.directory, 'options.directory is required');\n    assert(options.target, 'options.target is required');\n    this.options = Object.assign({}, defaults, options);\n\n    // compatible old options _lowercaseFirst_\n    if (this.options.lowercaseFirst === true) {\n      deprecate('lowercaseFirst is deprecated, use caseStyle instead');\n      this.options.caseStyle = 'lower';\n    }\n  }\n\n  /**\n   * attach items to target object. Mapping the directory to properties.\n   * `app/controller/group/repository.js` => `target.group.repository`\n   * @return {Object} target\n   * @since 1.0.0\n   */\n  load() {\n    const items = this.parse();\n    const target = this.options.target;\n    for (const item of items) {\n      debug('loading item %j', item);\n      // item { properties: [ 'a', 'b', 'c'], exports }\n      // => target.a.b.c = exports\n      item.properties.reduce((target, property, index) => {\n        let obj;\n        const properties = item.properties.slice(0, index + 1).join('.');\n        if (index === item.properties.length - 1) {\n          if (property in target) {\n            if (!this.options.override) throw new Error(`can't overwrite property '${properties}' from ${target[property][FULLPATH]} by ${item.fullpath}`);\n          }\n          obj = item.exports;\n          if (obj && !is.primitive(obj)) {\n            obj[FULLPATH] = item.fullpath;\n            obj[EXPORTS] = true;\n          }\n        } else {\n          obj = target[property] || {};\n        }\n        target[property] = obj;\n        debug('loaded %s', properties);\n        return obj;\n      }, target);\n    }\n    return target;\n  }\n\n  /**\n   * Parse files from given directories, then return an items list, each item contains properties and exports.\n   *\n   * For exmple, parse `app/controller/group/repository.js`\n   *\n   * ```\n   * module.exports = app => {\n   *   return class RepositoryController extends app.Controller {};\n   * }\n   * ```\n   *\n   * It returns a item\n   *\n   * ```\n   * {\n   *   properties: [ 'group', 'repository' ],\n   *   exports: app => { ... },\n   * }\n   * ```\n   *\n   * `Properties` is an array that contains the directory of a filepath.\n   *\n   * `Exports` depends on type, if exports is a function, it will be called. if initializer is specified, it will be called with exports for customizing.\n   * @return {Array} items\n   * @since 1.0.0\n   */\n  parse() {\n    const files = [ '**/*.js' ];\n    if (typeof this.options.ignore === 'string') {\n      files.push('!' + this.options.ignore);\n    }\n\n    let directories = this.options.directory;\n    if (!Array.isArray(directories)) {\n      directories = [ directories ];\n    }\n\n    const items = [];\n    debug('parsing %j', directories);\n    for (const directory of directories) {\n      const filepaths = globby.sync(files, { cwd: directory });\n      for (const filepath of filepaths) {\n        const fullpath = path.join(directory, filepath);\n        if (!fs.statSync(fullpath).isFile()) continue;\n        // get properties\n        // app/service/foo/bar.js => [ 'foo', 'bar' ]\n        const properties = getProperties(filepath, this.options);\n        // app/service/foo/bar.js => service.foo.bar\n        const pathName = directory.split(/\\/|\\\\/).slice(-1) + '.' + properties.join('.');\n        // get exports from the file\n        const exports = getExports(fullpath, this.options, pathName);\n        if (exports == null) continue;\n        if (is.class(exports)) exports.prototype.pathName = pathName;\n\n        items.push({ fullpath, properties, exports });\n        debug('parse %s, properties %j, export %j', fullpath, properties, exports);\n      }\n    }\n\n    return items;\n  }\n\n}\n\nmodule.exports = FileLoader;\nmodule.exports.EXPORTS = EXPORTS;\nmodule.exports.FULLPATH = FULLPATH;\n\n// convert file path to an array of properties\n// a/b/c.js => ['a', 'b', 'c']\nfunction getProperties(filepath, { caseStyle }) {\n  // if caseStyle is function, return the result of function\n  if (is.function(caseStyle)) {\n    const result = caseStyle(filepath);\n    assert(is.array(result), `caseStyle expect an array, but got ${result}`);\n    return result;\n  }\n  // use default camelize\n  return defaultCamelize(filepath, caseStyle);\n}\n\n// Get exports from filepath\n// If exports is null/undefined, it will be ignored\nfunction getExports(fullpath, { initializer, call, inject }, pathName) {\n  let exports = utils.loadFile(fullpath);\n\n  // process exports as you like\n  if (initializer) {\n    exports = initializer(exports, { path: fullpath, pathName });\n  }\n\n  // return exports when it's a class or generator\n  //\n  // module.exports = class Service {};\n  // or\n  // module.exports = function*() {}\n  if (is.class(exports) || is.generatorFunction(exports)) {\n    return exports;\n  }\n\n  // return exports after call when it's a function\n  //\n  // module.exports = function(app) {\n  //   return {};\n  // }\n  if (call && is.function(exports)) {\n    exports = exports(inject);\n    if (exports != null) {\n      return exports;\n    }\n  }\n\n  // return exports what is\n  return exports;\n}\n\nfunction defaultCamelize(filepath, caseStyle) {\n  const properties = filepath.replace(/\\.js$/, '').split('/');\n  return properties.map(property => {\n    if (!/^[a-z][a-z0-9_-]*$/i.test(property)) {\n      throw new Error(`${property} is not match 'a-z0-9_-' in ${filepath}`);\n    }\n\n    // use default camelize, will capitalize the first letter\n    // foo_bar.js > FooBar\n    // fooBar.js  > FooBar\n    // FooBar.js  > FooBar\n    // FooBar.js  > FooBar\n    // FooBar.js  > fooBar (if lowercaseFirst is true)\n    property = property.replace(/[_-][a-z]/ig, s => s.substring(1).toUpperCase());\n    let first = property[0];\n    switch (caseStyle) {\n      case 'lower':\n        first = first.toLowerCase();\n        break;\n      case 'upper':\n        first = first.toUpperCase();\n        break;\n      case 'camel':\n      default:\n    }\n    return first + property.substring(1);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/loader/context_loader.js":"'use strict';\n\nconst assert = require('assert');\nconst is = require('is-type-of');\nconst FileLoader = require('./file_loader');\nconst CLASSLOADER = Symbol('classLoader');\nconst EXPORTS = FileLoader.EXPORTS;\n\nclass ClassLoader {\n\n  constructor(options) {\n    assert(options.ctx, 'options.ctx is required');\n    const properties = options.properties;\n    this._cache = new Map();\n    this._ctx = options.ctx;\n\n    for (const property in properties) {\n      this.defineProperty(property, properties[property]);\n    }\n  }\n\n  defineProperty(property, values) {\n    Object.defineProperty(this, property, {\n      get() {\n        let instance = this._cache.get(property);\n        if (!instance) {\n          instance = getInstance(values, this._ctx);\n          this._cache.set(property, instance);\n        }\n        return instance;\n      },\n    });\n  }\n}\n\n/**\n * Same as {@link FileLoader}, but it will attach file to `inject[fieldClass]`. The exports will be lazy loaded, such as `ctx.group.repository`.\n * @extends FileLoader\n * @since 1.0.0\n */\nclass ContextLoader extends FileLoader {\n\n  /**\n   * @constructor\n   * @param {Object} options - options same as {@link FileLoader}\n   * @param {String} options.fieldClass - determine the field name of inject object.\n   */\n  constructor(options) {\n    assert(options.property, 'options.property is required');\n    assert(options.inject, 'options.inject is required');\n    const target = options.target = {};\n    if (options.fieldClass) {\n      options.inject[options.fieldClass] = target;\n    }\n    super(options);\n\n    const app = this.options.inject;\n    const property = options.property;\n\n    // define ctx.service\n    Object.defineProperty(app.context, property, {\n      get() {\n        // distinguish property cache,\n        // cache's lifecycle is the same with this context instance\n        // e.x. ctx.service1 and ctx.service2 have different cache\n        if (!this[CLASSLOADER]) {\n          this[CLASSLOADER] = new Map();\n        }\n        const classLoader = this[CLASSLOADER];\n\n        let instance = classLoader.get(property);\n        if (!instance) {\n          instance = getInstance(target, this);\n          classLoader.set(property, instance);\n        }\n        return instance;\n      },\n    });\n  }\n}\n\nmodule.exports = ContextLoader;\n\n\nfunction getInstance(values, ctx) {\n  // it's a directory when it has no exports\n  // then use ClassLoader\n  const Class = values[EXPORTS] ? values : null;\n  let instance;\n  if (Class) {\n    if (is.class(Class)) {\n      instance = new Class(ctx);\n    } else {\n      // it's just an object\n      instance = Class;\n    }\n  // Can't set property to primitive, so check again\n  // e.x. module.exports = 1;\n  } else if (is.primitive(values)) {\n    instance = values;\n  } else {\n    instance = new ClassLoader({ ctx, properties: values });\n  }\n  return instance;\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/loader/mixin/plugin.js":"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst debug = require('debug')('egg-core:plugin');\nconst sequencify = require('../../utils/sequencify');\nconst loadFile = require('../../utils').loadFile;\n\nmodule.exports = {\n\n  /**\n   * Load config/plugin.js from {EggLoader#loadUnits}\n   *\n   * plugin.js is written below\n   *\n   * ```js\n   * {\n   *   'xxx-client': {\n   *     enable: true,\n   *     package: 'xxx-client',\n   *     dep: [],\n   *     env: [],\n   *   },\n   *   // short hand\n   *   'rds': false,\n   *   'depd': {\n   *     enable: true,\n   *     path: 'path/to/depd'\n   *   }\n   * }\n   * ```\n   *\n   * If the plugin has path, Loader will find the module from it.\n   *\n   * Otherwise Loader will lookup follow the order by packageName\n   *\n   * 1. $APP_BASE/node_modules/${package}\n   * 2. $EGG_BASE/node_modules/${package}\n   *\n   * You can call `loader.plugins` that retrieve enabled plugins.\n   *\n   * ```js\n   * loader.plugins['xxx-client'] = {\n   *   name: 'xxx-client',                 // the plugin name, it can be used in `dep`\n   *   package: 'xxx-client',              // the package name of plugin\n   *   enable: true,                       // whether enabled\n   *   path: 'path/to/xxx-client',         // the directory of the plugin package\n   *   dep: [],                            // the dependent plugins, you can use the plugin name\n   *   env: [ 'local', 'unittest' ],       // specify the serverEnv that only enable the plugin in it\n   * }\n   * ```\n   *\n   * `loader.allPlugins` can be used when retrieve all plugins.\n   * @method EggLoader#loadPlugin\n   * @since 1.0.0\n   */\n  loadPlugin() {\n    // loader plugins from application\n    const appPlugins = this.readPluginConfigs(path.join(this.options.baseDir, 'config/plugin.default.js'));\n    debug('Loaded app plugins: %j', Object.keys(appPlugins));\n\n    // loader plugins from framework\n    const eggPluginConfigPaths = this.eggPaths.map(eggPath => path.join(eggPath, 'config/plugin.default.js'));\n    const eggPlugins = this.readPluginConfigs(eggPluginConfigPaths);\n    debug('Loaded egg plugins: %j', Object.keys(eggPlugins));\n\n    // loader plugins from process.env.EGG_PLUGINS\n    let customPlugins;\n    if (process.env.EGG_PLUGINS) {\n      try {\n        customPlugins = JSON.parse(process.env.EGG_PLUGINS);\n      } catch (e) {\n        debug('parse EGG_PLUGINS failed, %s', e);\n      }\n    }\n\n    // loader plugins from options.plugins\n    if (this.options.plugins) {\n      customPlugins = Object.assign({}, customPlugins, this.options.plugins);\n    }\n\n    if (customPlugins) {\n      for (const name in customPlugins) {\n        this.normalizePluginConfig(customPlugins, name);\n      }\n      debug('Loaded custom plugins: %j', Object.keys(customPlugins));\n    }\n\n    this.allPlugins = {};\n    this.appPlugins = appPlugins;\n    this.customPlugins = customPlugins;\n\n    this._extendPlugins(this.allPlugins, eggPlugins);\n    this._extendPlugins(this.allPlugins, appPlugins);\n    this._extendPlugins(this.allPlugins, customPlugins);\n\n    const enabledPluginNames = []; // enabled plugins that configured explicitly\n    const plugins = {};\n    const env = this.serverEnv;\n    for (const name in this.allPlugins) {\n      const plugin = this.allPlugins[name];\n\n      // resolve the real plugin.path based on plugin or package\n      plugin.path = this.getPluginPath(plugin, this.options.baseDir);\n\n      // read plugin infomation from ${plugin.path}/package.json\n      this.mergePluginConfig(plugin);\n\n      // disable the plugin that not match the serverEnv\n      if (env && plugin.env.length && plugin.env.indexOf(env) === -1) {\n        debug('Disable %j, as env is %j but got %j', name, plugin.env, env);\n        plugin.enable = false;\n        continue;\n      }\n\n      // Can't enable the plugin implicitly when it's disabled by application\n      if (appPlugins[name] && !appPlugins[name].enable) {\n        debug('Disable %j, as disabled by app', name);\n        continue;\n      }\n\n      plugins[name] = plugin;\n\n      if (plugin.enable) {\n        enabledPluginNames.push(name);\n      }\n    }\n\n    // retrieve the ordered plugins\n    this.orderPlugins = this.getOrderPlugins(plugins, enabledPluginNames);\n\n    const enablePlugins = {};\n    for (const plugin of this.orderPlugins) {\n      enablePlugins[plugin.name] = plugin;\n    }\n    debug('Loaded plugins: %j', Object.keys(enablePlugins));\n\n    /**\n     * Retrieve enabled plugins\n     * @member {Object} EggLoader#plugins\n     * @since 1.0.0\n     */\n    this.plugins = enablePlugins;\n  },\n\n  /*\n   * Read plugin.js from multiple directory\n   */\n  readPluginConfigs(configPaths) {\n    if (!Array.isArray(configPaths)) {\n      configPaths = [ configPaths ];\n    }\n\n    // read plugin.default.js and plugins.${env}.js\n    // note: can't use for-of\n    for (let i = 0, l = configPaths.length; i < l; i++) {\n      const configPath = configPaths[i];\n      if (this.serverEnv === 'default') continue;\n      configPaths.push(configPath.replace(/plugin\\.default\\.js$/, `plugin.${this.serverEnv}.js`));\n    }\n\n    const plugins = {};\n    for (let configPath of configPaths) {\n      // let plugin.js compatible\n      if (configPath.endsWith('plugin.default.js') && !fs.existsSync(configPath)) {\n        configPath = configPath.replace(/plugin\\.default\\.js$/, 'plugin.js');\n      }\n\n      if (!fs.existsSync(configPath)) {\n        continue;\n      }\n\n      const config = loadFile(configPath);\n\n      for (const name in config) {\n        this.normalizePluginConfig(config, name, configPath);\n      }\n\n      this._extendPlugins(plugins, config);\n    }\n\n    return plugins;\n  },\n\n  normalizePluginConfig(plugins, name, configPath) {\n    const plugin = plugins[name];\n\n    // plugin_name: false\n    if (typeof plugin === 'boolean') {\n      plugins[ name ] = {\n        name,\n        enable: plugin,\n        dependencies: [],\n        optionalDependencies: [],\n        env: [],\n        from: configPath,\n      };\n      return;\n    }\n\n    if (!('enable' in plugin)) {\n      plugin.enable = true;\n    }\n    plugin.name = name;\n    plugin.dependencies = plugin.dependencies || [];\n    plugin.optionalDependencies = plugin.optionalDependencies || [];\n    plugin.env = plugin.env || [];\n    plugin.from = configPath;\n    depCompatible(plugin);\n  },\n\n  // Read plugin infomation from package.json and merge\n  // {\n  //   eggPlugin: {\n  //     \"name\": \"\",    plugin name, must be same as name in config/plugin.js\n  //     \"dep\": [],     dependent plugins\n  //     \"env\": \"\"      env\n  //   }\n  // }\n  mergePluginConfig(plugin) {\n    let pkg;\n    let config;\n    const pluginPackage = path.join(plugin.path, 'package.json');\n    if (fs.existsSync(pluginPackage)) {\n      pkg = require(pluginPackage);\n      config = pkg.eggPlugin;\n      if (pkg.version) {\n        plugin.version = pkg.version;\n      }\n    }\n\n    const logger = this.options.logger;\n    if (!config) {\n      logger.warn(`[egg:loader] pkg.eggPlugin is missing in ${pluginPackage}`);\n      return;\n    }\n\n    if (config.name && config.name !== plugin.name) {\n      // pluginName is configured in config/plugin.js\n      // pluginConfigName is pkg.eggPath.name\n      logger.warn(`[egg:loader] pluginName(${plugin.name}) is different from pluginConfigName(${config.name})`);\n    }\n\n    // dep compatible\n    depCompatible(config);\n\n    for (const key of [ 'dependencies', 'optionalDependencies', 'env' ]) {\n      if (!plugin[key].length && Array.isArray(config[key])) {\n        plugin[key] = config[key];\n      }\n    }\n  },\n\n  getOrderPlugins(allPlugins, enabledPluginNames) {\n    // no plugins enabled\n    if (!enabledPluginNames.length) {\n      return [];\n    }\n\n    const result = sequencify(allPlugins, enabledPluginNames);\n    debug('Got plugins %j after sequencify', result);\n\n    // catch error when result.sequence is empty\n    if (!result.sequence.length) {\n      const err = new Error(`sequencify plugins has problem, missing: [${result.missingTasks}], recursive: [${result.recursiveDependencies}]`);\n      // find plugins which is required by the missing plugin\n      for (const missName of result.missingTasks) {\n        const requires = [];\n        for (const name in allPlugins) {\n          if (allPlugins[name].dependencies.indexOf(missName) >= 0) {\n            requires.push(name);\n          }\n        }\n        err.message += `\\n\\t>> Plugin [${missName}] is disabled or missed, but is required by [${requires}]`;\n      }\n\n      err.name = 'PluginSequencifyError';\n      throw err;\n    }\n\n    // log the plugins that be enabled implicitly\n    const implicitEnabledPlugins = [];\n    const requireMap = {};\n    result.sequence.forEach(name => {\n      for (const depName of allPlugins[name].dependencies) {\n        if (!requireMap[depName]) {\n          requireMap[depName] = [];\n        }\n        requireMap[depName].push(name);\n      }\n\n      if (!allPlugins[name].enable) {\n        implicitEnabledPlugins.push(name);\n        allPlugins[name].enable = true;\n      }\n    });\n    if (implicitEnabledPlugins.length) {\n      // Following plugins will be enabled implicitly.\n      //   - configclient required by [hsfclient]\n      //   - eagleeye required by [hsfclient]\n      //   - diamond required by [hsfclient]\n      this.options.logger.info(`Following plugins will be enabled implicitly.\\n${implicitEnabledPlugins.map(name => `  - ${name} required by [${requireMap[name]}]`).join('\\n')}`);\n    }\n\n    return result.sequence.map(name => allPlugins[name]);\n  },\n\n  // Get the real plugin path\n  getPluginPath(plugin) {\n    if (plugin.path) {\n      return plugin.path;\n    }\n\n    const name = plugin.package || plugin.name;\n    const lookupDirs = [];\n\n    // 尝试在以下目录找到匹配的插件\n    //  -> {APP_PATH}/node_modules\n    //    -> {EGG_PATH}/node_modules\n    //      -> $CWD/node_modules\n    lookupDirs.push(path.join(this.options.baseDir, 'node_modules'));\n\n    // 到 egg 中查找，优先从外往里查找\n    for (let i = this.eggPaths.length - 1; i >= 0; i--) {\n      const eggPath = this.eggPaths[i];\n      lookupDirs.push(path.join(eggPath, 'node_modules'));\n    }\n\n    // should find the $cwd/node_modules when test the plugins under npm3\n    lookupDirs.push(path.join(process.cwd(), 'node_modules'));\n\n    for (let dir of lookupDirs) {\n      dir = path.join(dir, name);\n      if (fs.existsSync(dir)) {\n        return fs.realpathSync(dir);\n      }\n    }\n\n    throw new Error(`Can not find plugin ${name} in \"${lookupDirs.join(', ')}\"`);\n  },\n\n  _extendPlugins(target, plugins) {\n    if (!plugins) {\n      return;\n    }\n    for (const name in plugins) {\n      const plugin = plugins[name];\n      let targetPlugin = target[name];\n      if (!targetPlugin) {\n        targetPlugin = target[name] = {};\n      }\n      if (targetPlugin.package && targetPlugin.package === plugin.package) {\n        this.options.logger.warn('plugin %s has been defined that is %j, but you define again in %s',\n          name, targetPlugin, plugin.from);\n      }\n      if (plugin.path || plugin.package) {\n        delete targetPlugin.path;\n        delete targetPlugin.package;\n      }\n      for (const prop in plugin) {\n        if (plugin[prop] === undefined) {\n          continue;\n        }\n        if (targetPlugin[prop] && Array.isArray(plugin[prop]) && !plugin[prop].length) {\n          continue;\n        }\n        targetPlugin[prop] = plugin[prop];\n      }\n    }\n  },\n\n};\n\nfunction depCompatible(plugin) {\n  if (plugin.dep && !(Array.isArray(plugin.dependencies) && plugin.dependencies.length)) {\n    plugin.dependencies = plugin.dep;\n    delete plugin.dep;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/utils/sequencify.js":"'use strict';\n\nfunction sequence(tasks, names, results, missing, recursive, nest, optional) {\n  names.forEach(function(name) {\n    if (results.indexOf(name) !== -1) {\n      return; // de-dup results\n    }\n    const node = tasks[name];\n    if (!node) {\n      if (optional === true) {\n        return;\n      }\n      missing.push(name);\n    } else if (nest.indexOf(name) > -1) {\n      nest.push(name);\n      recursive.push(nest.slice(0));\n      nest.pop(name);\n    } else if (node.dependencies.length || node.optionalDependencies.length) {\n      nest.push(name);\n      if (node.dependencies.length) {\n        sequence(tasks, node.dependencies, results, missing, recursive, nest);\n      }\n      if (node.optionalDependencies.length) {\n        sequence(tasks, node.optionalDependencies, results, missing, recursive, nest, true);\n      }\n      nest.pop(name);\n    }\n    if (optional === true) return;\n    results.push(name);\n  });\n}\n\n// tasks: object with keys as task names\n// names: array of task names\nmodule.exports = function(tasks, names) {\n  let results = []; // the final sequence\n  const missing = []; // missing tasks\n  const recursive = []; // recursive task dependencies\n\n  sequence(tasks, names, results, missing, recursive, []);\n\n  if (missing.length || recursive.length) {\n    results = []; // results are incomplete at best, completely wrong at worst, remove them to avoid confusion\n  }\n\n  return {\n    sequence: results,\n    missingTasks: missing,\n    recursiveDependencies: recursive,\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/loader/mixin/config.js":"'use strict';\n\nconst debug = require('debug')('egg-core:config');\nconst fs = require('fs');\nconst path = require('path');\nconst extend = require('extend2');\nconst assert = require('assert');\n\n\nmodule.exports = {\n\n  /**\n   * Load config/config.js\n   *\n   * Will merge config.default.js 和 config.${env}.js\n   *\n   * @method EggLoader#loadConfig\n   * @since 1.0.0\n   */\n  loadConfig() {\n    const target = {};\n\n    const names = [\n      'config.default.js',\n      `config.${this.serverEnv}.js`,\n    ];\n\n    // Load Application config first\n    const appConfig = this._preloadAppConfig();\n\n    //   plugin config.default\n    //     framework config.default\n    //       app config.default\n    //         plugin config.{env}\n    //           framework config.{env}\n    //             app config.{env}\n    for (const filename of names) {\n      for (const unit of this.getLoadUnits()) {\n        const isApp = unit.type === 'app';\n        const config = this._loadConfig(unit.path, filename, isApp ? undefined : appConfig, unit.type);\n\n        if (!config) {\n          continue;\n        }\n\n        debug('Loaded config %s/%s, %j', unit.path, filename, config);\n        extend(true, target, config);\n      }\n    }\n\n    // You can manipulate the order of app.config.coreMiddleware and app.config.appMiddleware in app.js\n    target.coreMiddleware = target.coreMiddlewares = target.coreMiddleware || [];\n    target.appMiddleware = target.appMiddlewares = target.middleware || [];\n\n    this.config = target;\n  },\n\n  _preloadAppConfig() {\n    const names = [\n      'config.default.js',\n      `config.${this.serverEnv}.js`,\n    ];\n    const target = {};\n    for (const filename of names) {\n      const config = this._loadConfig(this.options.baseDir, filename, undefined, 'app');\n      extend(true, target, config);\n    }\n    return target;\n  },\n\n  _loadConfig(dirpath, filename, extraInject, type) {\n    const isPlugin = type === 'plugin';\n    const isApp = type === 'app';\n\n    let filepath = path.join(dirpath, 'config', filename);\n    // let config.js compatible\n    if (filename === 'config.default.js' && !fs.existsSync(filepath)) {\n      filepath = path.join(dirpath, 'config/config.js');\n    }\n    const config = this.loadFile(filepath, this.appInfo, extraInject);\n\n    if (!config) {\n      return null;\n    }\n\n    if (isPlugin || isApp) {\n      assert(!config.coreMiddleware, 'Can not define coreMiddleware in app or plugin');\n    }\n    if (!isApp) {\n      assert(!config.middleware, 'Can not define middleware in ' + filepath);\n    }\n\n    return config;\n  },\n\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/loader/mixin/extend.js":"'use strict';\n\nconst debug = require('debug')('egg-core:extend');\nconst path = require('path');\nconst utils = require('../../utils');\n\nconst orginalPrototypes = {\n  request: require('koa/lib/request'),\n  response: require('koa/lib/response'),\n  context: require('koa/lib/context'),\n  application: require('koa/lib/application'),\n};\n\nmodule.exports = {\n\n  /**\n   * mixin Agent.prototype\n   * @method EggLoader#loadAgentExtend\n   * @since 1.0.0\n   */\n  loadAgentExtend() {\n    this.loadExtend('agent', this.app);\n  },\n\n  /**\n   * mixin Application.prototype\n   * @method EggLoader#loadApplicationExtend\n   * @since 1.0.0\n   */\n  loadApplicationExtend() {\n    this.loadExtend('application', this.app);\n  },\n\n  /**\n   * mixin Request.prototype\n   * @method EggLoader#loadRequestExtend\n   * @since 1.0.0\n   */\n  loadRequestExtend() {\n    this.loadExtend('request', this.app.request);\n  },\n\n  /**\n   * mixin Response.prototype\n   * @method EggLoader#loadResponseExtend\n   * @since 1.0.0\n   */\n  loadResponseExtend() {\n    this.loadExtend('response', this.app.response);\n  },\n\n  /**\n   * mixin Context.prototype\n   * @method EggLoader#loadContextExtend\n   * @since 1.0.0\n   */\n  loadContextExtend() {\n    this.loadExtend('context', this.app.context);\n  },\n\n  /**\n   * mixin app.Helper.prototype\n   * @method EggLoader#loadHelperExtend\n   * @since 1.0.0\n   */\n  loadHelperExtend() {\n    if (this.app && this.app.Helper) {\n      this.loadExtend('helper', this.app.Helper.prototype);\n    }\n  },\n\n  /**\n   * Loader app/extend/xx.js to `prototype`,\n   * @method loadExtend\n   * @param {String} name - filename which may be `app/extend/{name}.js`\n   * @param {Object} proto - prototype that mixed\n   * @since 1.0.0\n   */\n  loadExtend(name, proto) {\n    // All extend files\n    const filepaths = this.getLoadUnits().map(unit => path.join(unit.path, 'app/extend', name));\n    // if use mm.env and serverEnv is not unittest\n    const isAddUnittest = 'EGG_MOCK_SERVER_ENV' in process.env && this.serverEnv !== 'unittest';\n    for (let i = 0, l = filepaths.length; i < l; i++) {\n      const filepath = filepaths[i];\n      filepaths.push(filepath + `.${this.serverEnv}`);\n      if (isAddUnittest) filepaths.push(filepath + '.unittest');\n    }\n\n    const mergeRecord = new Map();\n    for (const filepath of filepaths) {\n      if (!utils.existsModule(filepath)) {\n        continue;\n      }\n\n      const ext = utils.loadFile(filepath);\n\n      const properties = Object.getOwnPropertyNames(ext)\n        .concat(Object.getOwnPropertySymbols(ext));\n\n      for (const property of properties) {\n        if (mergeRecord.has(property)) {\n          debug('Property: \"%s\" already exists in \"%s\"，it will be redefined by \"%s\"',\n            property, mergeRecord.get(property), filepath);\n        }\n\n        // Copy descriptor\n        let descriptor = Object.getOwnPropertyDescriptor(ext, property);\n        let orginalDescriptor = Object.getOwnPropertyDescriptor(proto, property);\n        if (!orginalDescriptor) {\n          // try to get descriptor from orginalPrototypes\n          const orginalProto = orginalPrototypes[name];\n          if (orginalProto) {\n            orginalDescriptor = Object.getOwnPropertyDescriptor(orginalProto, property);\n          }\n        }\n        if (orginalDescriptor) {\n          // don't override descriptor\n          descriptor = Object.assign({}, descriptor);\n          if (!descriptor.set && orginalDescriptor.set) {\n            descriptor.set = orginalDescriptor.set;\n          }\n          if (!descriptor.get && orginalDescriptor.get) {\n            descriptor.get = orginalDescriptor.get;\n          }\n        }\n        Object.defineProperty(proto, property, descriptor);\n        mergeRecord.set(property, filepath);\n      }\n      debug('merge %j to %s from %s', Object.keys(ext), name, filepath);\n    }\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/loader/mixin/custom.js":"'use strict';\n\nconst path = require('path');\n\nmodule.exports = {\n\n  /**\n   * load app.js\n   *\n   * @example\n   * ```js\n   * module.exports = function(app) {\n   *   // can do everything\n   *   do();\n   *\n   *   // if you will invork asynchronous, you can use readyCallback\n   *   const done = app.readyCallback();\n   *   doAsync(done);\n   * }\n   * ```\n   * @since 1.0.0\n   */\n  loadCustomApp() {\n    this.getLoadUnits()\n      .forEach(unit => this.loadFile(path.join(unit.path, 'app.js')));\n  },\n\n  /**\n   * Load agent.js, same as {@link EggLoader#loadCustomApp}\n   */\n  loadCustomAgent() {\n    this.getLoadUnits()\n      .forEach(unit => this.loadFile(path.join(unit.path, 'agent.js')));\n  },\n\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/loader/mixin/service.js":"'use strict';\n\nconst path = require('path');\n\nmodule.exports = {\n\n  /**\n   * Load app/service\n   * @method EggLoader#loadService\n   * @param {Object} opt - LoaderOptions\n   * @since 1.0.0\n   */\n  loadService(opt) {\n    const servicePaths = this.getLoadUnits().map(unit => {\n      return path.join(unit.path, 'app/service');\n    });\n\n    // 载入到 app.serviceClasses\n    opt = Object.assign({\n      call: true,\n      caseStyle: 'lower',\n      fieldClass: 'serviceClasses',\n    }, opt);\n    this.loadToContext(servicePaths, 'service', opt);\n  },\n\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/loader/mixin/middleware.js":"'use strict';\n\nconst join = require('path').join;\nconst is = require('is-type-of');\nconst inspect = require('util').inspect;\nconst assert = require('assert');\nconst debug = require('debug')('egg-core:middleware');\nconst pathMatching = require('egg-path-matching');\nconst utils = require('../../utils');\n\nmodule.exports = {\n\n  /**\n   * Load app/middleware\n   *\n   * app.config.xx is the options of the middleware xx that has same name as config\n   *\n   * @method EggLoader#loadMiddleware\n   * @param {Object} opt - LoaderOptions\n   * @example\n   * ```js\n   * // app/middleware/status.js\n   * module.exports = function(options, app) {\n   *   // options == app.config.status\n   *   return function*(next) {\n   *     yield next;\n   *   }\n   * }\n   * ```\n   * @since 1.0.0\n   */\n  loadMiddleware(opt) {\n    const app = this.app;\n\n    // load middleware to app.middleware\n    opt = Object.assign({\n      call: false,\n      override: true,\n      caseStyle: 'lower',\n    }, opt);\n    const middlewarePaths = this.getLoadUnits().map(unit => join(unit.path, 'app/middleware'));\n    this.loadToApp(middlewarePaths, 'middlewares', opt);\n\n    this.options.logger.info('Use coreMiddleware order: %j', this.config.coreMiddleware);\n    this.options.logger.info('Use appMiddleware order: %j', this.config.appMiddleware);\n\n    // use middleware ordered by app.config.coreMiddleware and app.config.appMiddleware\n    const middlewareNames = this.config.coreMiddleware.concat(this.config.appMiddleware);\n    debug('middlewareNames: %j', middlewareNames);\n    const middlewaresMap = new Map();\n    for (const name of middlewareNames) {\n      if (!app.middlewares[name]) {\n        throw new TypeError(`Middleware ${name} not found`);\n      }\n      if (middlewaresMap.has(name)) {\n        throw new TypeError(`Middleware ${name} redefined`);\n      }\n      middlewaresMap.set(name, true);\n\n      const options = this.config[name] || {};\n      let mw = app.middlewares[name];\n      mw = mw(options, app);\n      assert(is.function(mw), `Middleware ${name} must be a function, but actual is ${inspect(mw)}`);\n      mw._name = name;\n      // middlewares support options.enable, options.ignore and options.match\n      mw = wrapMiddleware(mw, options);\n      if (mw) {\n        app.use(mw);\n        debug('Use middleware: %s with options: %j', name, options);\n        this.options.logger.info('[egg:loader] Use middleware: %s', name);\n      } else {\n        this.options.logger.info('[egg:loader] Disable middleware: %s', name);\n      }\n    }\n\n    this.options.logger.info('[egg:loader] Loaded middleware from %j', middlewarePaths);\n  },\n\n};\n\nfunction wrapMiddleware(mw, options) {\n  // support options.enable\n  if (options.enable === false) return null;\n\n  // support async function\n  mw = utils.middleware(mw);\n\n  // support options.match and options.ignore\n  if (!options.match && !options.ignore) return mw;\n  const match = pathMatching(options);\n\n  const fn = function* (next) {\n    if (!match(this)) return yield next;\n    yield mw.call(this, next);\n  };\n  fn._name = mw._name + 'middlewareWrapper';\n  return fn;\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-path-matching/index.js":"'use strict';\n\nconst pathToRegexp = require('path-to-regexp');\n\nmodule.exports = function(options) {\n  options = options || {};\n  if (options.match && options.ignore) throw new Error('options.match and options.ignore can not both present');\n  if (!options.match && !options.ignore) return () => true;\n\n  const matchFn = options.match ? toPathMatch(options.match) : toPathMatch(options.ignore);\n\n  return function pathMatch(ctx) {\n    const matched = matchFn(ctx);\n    return options.match ? matched : !matched;\n  };\n};\n\nfunction toPathMatch(pattern) {\n  if (typeof pattern === 'string') {\n    const reg = pathToRegexp(pattern, [], { end: false });\n    return ctx => reg.test(ctx.path);\n  }\n  if (pattern instanceof RegExp) return ctx => pattern.test(ctx.path);\n  if (typeof pattern === 'function') return pattern;\n  if (Array.isArray(pattern)) {\n    const matchs = pattern.map(item => toPathMatch(item));\n    return ctx => matchs.some(match => match(ctx));\n  }\n  throw new Error('match/ignore pattern must be RegExp, Array or String, but got ' + pattern);\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/loader/mixin/controller.js":"'use strict';\n\nconst path = require('path');\nconst is = require('is-type-of');\nconst utility = require('utility');\n\nmodule.exports = {\n\n  /**\n   * Load app/controller\n   * @param {Object} opt - LoaderOptions\n   * @since 1.0.0\n   */\n  loadController(opt) {\n    opt = Object.assign({\n      caseStyle: 'lower',\n      initializer: (obj, opt) => {\n        // return class if it exports a function\n        // ```js\n        // module.exports = app => {\n        //   return class HomeController extends app.Controller {};\n        // }\n        // ```\n        if (is.function(obj) && !is.generatorFunction(obj) && !is.class(obj)) {\n          obj = obj(this.app);\n        }\n        if (is.promise(obj)) {\n          // module.exports = async ctx => ctx.body = 'hello';\n          const displayPath = path.relative(this.app.baseDir, opt.path);\n          throw new Error(`${displayPath} cannot be async function`);\n        }\n        if (is.class(obj)) {\n          obj.prototype.pathName = opt.pathName;\n          return wrapClass(obj);\n        }\n        if (is.object(obj)) {\n          return wrapObject(obj, opt.path);\n        }\n        return obj;\n      },\n    }, opt);\n    const controllerBase = path.join(this.options.baseDir, 'app/controller');\n\n    this.loadToApp(controllerBase, 'controller', opt);\n    this.options.logger.info('[egg:loader] Controller loaded: %s', controllerBase);\n  },\n\n};\n\n// wrap the class, yield a object with middlewares\nfunction wrapClass(Controller) {\n  const keys = Object.getOwnPropertyNames(Controller.prototype);\n  const ret = {};\n  for (const key of keys) {\n    // getOwnPropertyNames will return constructor\n    // that should be ignored\n    if (key === 'constructor') {\n      continue;\n    }\n    if (is.function(Controller.prototype[key])) {\n      ret[key] = methodToMiddleware(Controller, key);\n    }\n  }\n  return ret;\n\n  function methodToMiddleware(Controller, key) {\n    return function* classControllerMiddleware() {\n      const controller = new Controller(this);\n      const r = controller[key](this);\n      // TODO: if we can check async function, then we can check it out of the middleware\n      if (is.generator(r) || is.promise(r)) {\n        yield r;\n      }\n    };\n  }\n}\n\n// wrap the method of the object, method can recieve ctx as it's first argument\nfunction wrapObject(obj, path) {\n  const keys = Object.keys(obj);\n  const ret = {};\n  for (const key of keys) {\n    if (is.function(obj[key])) {\n      const names = utility.getParamNames(obj[key]);\n      if (names[0] === 'next') {\n        throw new Error(`controller \\`${key}\\` should not use next as argument from file ${path}`);\n      }\n      ret[key] = functionToMiddleware(obj[key]);\n    } else if (is.object(obj[key])) {\n      ret[key] = wrapObject(obj[key], path);\n    }\n  }\n  return ret;\n\n  function functionToMiddleware(func) {\n    const objectControllerMiddleware = function* () {\n      const r = func.call(this, this);\n      if (is.generator(r) || is.promise(r)) {\n        yield r;\n      }\n    };\n    for (const key in func) {\n      if (utility.has(func, key)) {\n        objectControllerMiddleware[key] = func[key];\n      }\n    }\n    return objectControllerMiddleware;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-core/lib/loader/mixin/router.js":"'use strict';\n\nconst path = require('path');\n\nmodule.exports = {\n\n  /**\n   * Load app/router.js\n   * @method EggLoader#loadRouter\n   * @param {Object} opt - LoaderOptions\n   * @since 1.0.0\n   */\n  loadRouter() {\n    // 加载 router.js\n    this.loadFile(path.join(this.options.baseDir, 'app/router.js'));\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-cookies/lib/cookies.js":"'use strict';\n\nconst assert = require('assert');\nconst utility = require('utility');\nconst Keygrip = require('./keygrip');\nconst Cookie = require('./cookie');\n\nconst KEYS_ARRAY = Symbol('eggCookies:keysArray');\nconst KEYS = Symbol('eggCookies:keys');\nconst keyCache = new Map();\n\n/**\n * cookies for egg\n * extend pillarjs/cookies, add encrypt and decrypt\n */\n\nclass Cookies {\n  constructor(ctx, keys) {\n    this[KEYS_ARRAY] = keys;\n    this._keys = keys;\n    this.ctx = ctx;\n    this.secure = this.ctx.secure;\n    this.app = ctx.app;\n  }\n\n  get keys() {\n    if (!this[KEYS]) {\n      const keysArray = this[KEYS_ARRAY];\n      assert(Array.isArray(keysArray), '.keys required for encrypt/sign cookies');\n      const cache = keyCache.get(keysArray);\n      if (cache) {\n        this[KEYS] = cache;\n      } else {\n        this[KEYS] = new Keygrip(this[KEYS_ARRAY]);\n        keyCache.set(keysArray, this[KEYS]);\n      }\n    }\n\n    return this[KEYS];\n  }\n\n  /**\n   * get cookie value by name\n   * @param  {String} name - cookie's name\n   * @param  {Object} opts - cookies' options\n   *            - {Boolean} signed - defualt to true\n   *            - {Boolean} encrypt - defualt to false\n   * @return {String} value - cookie's value\n   */\n  get(name, opts) {\n    opts = encryptOrSigned(opts);\n\n    const header = this.ctx.get('cookie');\n    if (!header) return;\n\n    const match = header.match(getPattern(name));\n    if (!match) return;\n\n    let value = match[1];\n    if (!opts.encrypt && !opts.signed) return value;\n\n    // signed\n    if (opts.signed) {\n      const sigName = name + '.sig';\n      const sigValue = this.get(sigName, { signed: false });\n      if (!sigValue) return;\n\n      const raw = name + '=' + value;\n      const index = this.keys.verify(raw, sigValue);\n      if (index < 0) {\n        // can not match any key, remove ${name}.sig\n        this.set(sigName, null, { path: '/', signed: false });\n        return;\n      }\n      if (index > 0) {\n        // not signed by the first key, update sigValue\n        this.set(sigName, this.keys.sign(raw), { signed: false });\n      }\n      return value;\n    }\n\n    // encrypt\n    value = utility.base64decode(value, true, 'buffer');\n    const res = this.keys.decrypt(value);\n    return res ? res.value.toString() : undefined;\n  }\n\n  set(name, value, opts) {\n    opts = encryptOrSigned(opts);\n    value = value || '';\n    if (!this.secure && opts.secure) {\n      throw new Error('Cannot send secure cookie over unencrypted connection');\n    }\n    if (opts.secure === undefined) opts.secure = this.secure;\n\n    let headers = this.ctx.response.get('set-cookie') || [];\n    if (!Array.isArray(headers)) headers = [ headers ];\n\n    // encrypt\n    if (opts.encrypt) {\n      value = value && utility.base64encode(this.keys.encrypt(value), true);\n    }\n\n    // http://browsercookielimits.squawky.net/\n    if (value.length > 4093) {\n      this.app.emit('cookieLimitExceed', { name, value, ctx: this.ctx });\n    }\n\n    const cookie = new Cookie(name, value, opts);\n    headers = pushCookie(headers, cookie);\n\n    // signed\n    if (opts.signed) {\n      cookie.value = value && this.keys.sign(cookie.toString());\n      cookie.name += '.sig';\n      headers = pushCookie(headers, cookie);\n    }\n\n    this.ctx.set('set-cookie', headers);\n    return this;\n  }\n}\n\nconst partternCache = new Map();\nfunction getPattern(name) {\n  const cache = partternCache.get(name);\n  if (cache) return cache;\n  const reg = new RegExp(\n    '(?:^|;) *' +\n    name.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&') +\n    '=([^;]*)'\n  );\n  partternCache.set(name, reg);\n  return reg;\n}\n\nfunction encryptOrSigned(opts) {\n  opts = opts || {};\n  // encrypt default to false, signed default to true.\n  // disable singed when encrypt is true.\n  if (opts.encrypt) opts.signed = false;\n  if (opts.signed !== false) opts.signed = true;\n  return opts;\n}\n\nfunction pushCookie(cookies, cookie) {\n  if (cookie.attrs.overwrite) {\n    cookies = cookies.filter(c => !c.startsWith(cookie.name + '='));\n  }\n  cookies.push(cookie.toHeader());\n  return cookies;\n}\n\nmodule.exports = Cookies;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-cookies/lib/keygrip.js":"'use strict';\n\nconst debug = require('debug')('egg-cookies:keygrip');\nconst crypto = require('crypto');\nconst assert = require('assert');\nconst constantTimeCompare = require('scmp');\n\nconst replacer = {\n  '/': '_',\n  '+': '-',\n  '=': '',\n};\n\n// patch from https://github.com/crypto-utils/keygrip\n\nclass Keygrip {\n  constructor(keys) {\n    assert(Array.isArray(keys) && keys.length, 'keys must be provided and should be an array');\n\n    this.keys = keys;\n    this.hash = 'sha256';\n    this.cipher = 'aes-256-cbc';\n  }\n\n  // encrypt a message\n  encrypt(data, key) {\n    key = key || this.keys[0];\n    const cipher = crypto.createCipher(this.cipher, key);\n    return crypt(cipher, data);\n  }\n\n  // decrypt a single message\n  // returns false on bad decrypts\n  decrypt(data, key) {\n    if (!key) {\n      // decrypt every key\n      const keys = this.keys;\n      for (let i = 0; i < keys.length; i++) {\n        const value = this.decrypt(data, keys[i]);\n        if (value !== false) return { value, index: i };\n      }\n      return false;\n    }\n\n    try {\n      const cipher = crypto.createDecipher(this.cipher, key);\n      return crypt(cipher, data);\n    } catch (err) {\n      debug('crypt error', err.stack);\n      return false;\n    }\n  }\n\n  sign(data, key) {\n    // default to the first key\n    key = key || this.keys[0];\n\n    return crypto\n      .createHmac(this.hash, key)\n      .update(data)\n      .digest('base64')\n      .replace(/\\/|\\+|=/g, x => replacer[x]);\n  }\n\n  verify(data, digest) {\n    const keys = this.keys;\n    for (let i = 0; i < keys.length; i++) {\n      if (constantTimeCompare(new Buffer(digest), new Buffer(this.sign(data, keys[i])))) {\n        debug('data %s match key %s', data, keys[i]);\n        return i;\n      }\n    }\n    return -1;\n  }\n}\n\nfunction crypt(cipher, data) {\n  const text = cipher.update(data, 'utf8');\n  const pad = cipher.final();\n  return Buffer.concat([ text, pad ]);\n}\n\nmodule.exports = Keygrip;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg-cookies/lib/cookie.js":"'use strict';\n\nconst assert = require('assert');\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n* RegExp to match Same-Site cookie attribute value.\n* https://en.wikipedia.org/wiki/HTTP_cookie#SameSite_cookie\n*/\n\nconst sameSiteRegExp = /^(?:lax|strict)$/i;\n\nclass Cookie {\n  constructor(name, value, attrs) {\n    assert(fieldContentRegExp.test(name), 'argument name is invalid');\n    assert(!value || fieldContentRegExp.test(value), 'argument value is invalid');\n\n    this.name = name;\n    this.value = value || '';\n    this.attrs = mergeDefaultAttrs(attrs);\n    assert(!this.attrs.path || fieldContentRegExp.test(this.attrs.path), 'argument option path is invalid');\n    assert(!this.attrs.domain || fieldContentRegExp.test(this.attrs.domain), 'argument option domain is invalid');\n    assert(!this.attrs.sameSite || this.attrs.sameSite === true || sameSiteRegExp.test(this.attrs.sameSite), 'argument option sameSite is invalid');\n    if (!value) this.attrs.expires = new Date(0);\n  }\n\n  toString() {\n    return this.name + '=' + this.value;\n  }\n\n  toHeader() {\n    let header = this.toString();\n    const attrs = this.attrs;\n    if (attrs.maxAge) attrs.expires = new Date(Date.now() + attrs.maxAge);\n    if (attrs.path) header += '; path=' + attrs.path;\n    if (attrs.expires) header += '; expires=' + attrs.expires.toUTCString();\n    if (attrs.domain) header += '; domain=' + attrs.domain;\n    if (attrs.sameSite) header += '; samesite=' + (attrs.sameSite === true ? 'strict' : attrs.sameSite.toLowerCase());\n    if (attrs.secure) header += '; secure';\n    if (attrs.httpOnly) header += '; httponly';\n\n    return header;\n  }\n}\n\nconst ATTRS = [ 'path', 'expires', 'domain', 'httpOnly', 'secure', 'maxAge', 'overwrite', 'sameSite' ];\nfunction mergeDefaultAttrs(attrs) {\n  const merged = {\n    path: '/',\n    httpOnly: true,\n    secure: false,\n    overwrite: false,\n    sameSite: false,\n  };\n  if (!attrs) return merged;\n\n  for (let i = 0; i < ATTRS.length; i++) {\n    const key = ATTRS[i];\n    if (key in attrs) merged[key] = attrs[key];\n  }\n  return merged;\n}\n\nmodule.exports = Cookie;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/core/context_httpclient.js":"'use strict';\n\nclass ContextHttpClient {\n  constructor(ctx) {\n    this.ctx = ctx;\n    this.app = ctx.app;\n  }\n\n  /**\n   * http request helper base on {@link HttpClient}, it will auto save httpclient log.\n   * Keep the same api with {@link Application#curl}.\n   *\n   * @param {String|Object} url - request url address.\n   * @param {Object} [options] - options for request.\n   * @return {Object} see {@link Application#curl}\n   */\n  curl(url, options) {\n    options = options || {};\n    options.ctx = this.ctx;\n    return this.app.curl(url, options);\n  }\n\n  request(url, options) {\n    return this.curl(url, options);\n  }\n}\n\nmodule.exports = ContextHttpClient;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/core/messenger.js":"'use strict';\n\nconst debug = require('debug')('egg:util:messenger');\nconst is = require('is-type-of');\nconst sendmessage = require('sendmessage');\nconst EventEmitter = require('events');\n\nclass Messenger extends EventEmitter {\n\n  constructor() {\n    super();\n    this.pid = String(process.pid);\n    // pids of agent or app maneged by master\n    // - retrieve app worker pids when it's an agent worker\n    // - retrieve agent worker pids when it's an app worker\n    this.opids = [];\n    this.on('egg-pids', pids => {\n      this.opids = pids;\n    });\n    this._onMessage = this._onMessage.bind(this);\n    process.on('message', this._onMessage);\n  }\n\n  /**\n   * Send message to all agent and app\n   * @param {String} action - message key\n   * @param {Object} data - message value\n   * @return {Messenger} this\n   */\n  broadcast(action, data) {\n    debug('[%s] broadcast %s with %j', this.pid, action, data);\n    this.send(action, data, 'app');\n    this.send(action, data, 'agent');\n    return this;\n  }\n\n  /**\n   * send message to the specified process\n   * @param {String} pid - the process id of the receiver\n   * @param {String} action - message key\n   * @param {Object} data - message value\n   * @return {Messenger} this\n   */\n  sendTo(pid, action, data) {\n    debug('[%s] send %s with %j to %s', this.pid, action, data, pid);\n    sendmessage(process, {\n      action,\n      data,\n      receiverPid: String(pid),\n    });\n    return this;\n  }\n\n  /**\n   * send message to one app worker by random\n   * - if it's running in agent, it will send to one of app workers\n   * - if it's running in app, it will send to agent\n   * @param {String} action - message key\n   * @param {Object} data - message value\n   * @return {Messenger} this\n   */\n  sendRandom(action, data) {\n    /* istanbul ignore if */\n    if (!this.opids.length) return this;\n    const pid = random(this.opids);\n    this.sendTo(String(pid), action, data);\n    return this;\n  }\n\n  /**\n   * send message to app\n   * @param {String} action - message key\n   * @param {Object} data - message value\n   * @return {Messenger} this\n   */\n  sendToApp(action, data) {\n    debug('[%s] send %s with %j to all app', this.pid, action, data);\n    this.send(action, data, 'app');\n    return this;\n  }\n\n  /**\n   * send message to agent\n   * @param {String} action - message key\n   * @param {Object} data - message value\n   * @return {Messenger} this\n   */\n  sendToAgent(action, data) {\n    debug('[%s] send %s with %j to all agent', this.pid, action, data);\n    this.send(action, data, 'agent');\n    return this;\n  }\n\n  /**\n   * @param {String} action - message key\n   * @param {Object} data - message value\n   * @param {String} to - let master know how to send message\n   * @return {Messenger} this\n   */\n  send(action, data, to) {\n    sendmessage(process, {\n      action,\n      data,\n      to,\n    });\n    return this;\n  }\n\n  _onMessage(message) {\n    if (message && is.string(message.action)) {\n      debug('[%s] got message %s with %j, receiverPid: %s',\n        this.pid, message.action, message.data, message.receiverPid);\n      this.emit(message.action, message.data);\n    }\n  }\n\n  close() {\n    process.removeListener('message', this._onMessage);\n    this.removeAllListeners();\n  }\n\n  /**\n   * @method Messenger#on\n   * @param {String} action - message key\n   * @param {Object} data - message value\n   */\n}\n\nmodule.exports = Messenger;\n\nfunction random(arr) {\n  const index = Math.floor(Math.random() * arr.length);\n  return arr[index];\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/core/httpclient.js":"'use strict';\n\nconst Agent = require('agentkeepalive');\nconst HttpsAgent = require('agentkeepalive').HttpsAgent;\nconst urllib = require('urllib');\n\nmodule.exports = app => {\n  const HttpClient = app.config.httpclient.enableDNSCache ?\n    require('./dnscache_httpclient') : urllib.HttpClient;\n\n  const config = app.config.httpclient;\n\n  return new HttpClient({\n    app,\n    agent: new Agent(config),\n    httpsAgent: new HttpsAgent(config),\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/core/logger.js":"'use strict';\n\nconst Loggers = require('egg-logger').EggLoggers;\n\nmodule.exports = function createLoggers(app) {\n  const loggerConfig = app.config.logger;\n  loggerConfig.type = app.type;\n\n  if (app.config.env === 'prod' && loggerConfig.level === 'DEBUG') {\n    loggerConfig.level = 'INFO';\n  }\n\n  const loggers = new Loggers(app.config);\n\n  // won't print to console after started, except for local and unittest\n  app.ready(() => {\n    if (app.config.env !== 'local' && app.config.env !== 'unittest') {\n      loggers.disableConsole();\n    }\n  });\n  loggers.coreLogger.info('[egg:logger] init all loggers with options: %j', loggerConfig);\n\n  return loggers;\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/core/singleton.js":"'use strict';\n\nconst assert = require('assert');\n\nclass Singleton {\n  constructor(options = {}) {\n    assert(options.name, '[egg:singleton] Singleton#constructor options.name is required');\n    assert(options.app, '[egg:singleton] Singleton#constructor options.app is required');\n    assert(options.create, '[egg:singleton] Singleton#constructor options.create is required');\n    assert(!options.app[options.name], `${options.name} is already exists in app`);\n    this.clients = new Map();\n    this.app = options.app;\n    this.name = options.name;\n    this.create = options.create;\n    /* istanbul ignore next */\n    this.options = options.app.config[this.name] || {};\n  }\n\n  init() {\n    const options = this.options;\n    assert(!(options.client && options.clients),\n      `eggg:singleton ${this.name} can not set options.client and options.clients both`);\n\n    // alias app[name] as client, but still support createInstance method\n    if (options.client) {\n      const client = this.createInstance(options.client);\n      this.app[this.name] = client;\n      assert(!client.createInstance, 'singleton instance should not have createInstance method');\n      client.createInstance = this.createInstance.bind(this);\n      return;\n    }\n\n    // multi clent, use app[name].getInstance(id)\n    if (options.clients) {\n      for (const id in options.clients) {\n        this.clients.set(id, this.createInstance(options.clients[id]));\n      }\n      this.app[this.name] = this;\n      return;\n    }\n\n    // no config.clients and config.client\n    this.app[this.name] = this;\n  }\n\n  get(id) {\n    return this.clients.get(id);\n  }\n\n  createInstance(config) {\n    // options.default will be merge in to options.clients[id]\n    config = Object.assign({}, this.options.default, config);\n    return this.create(config, this.app);\n  }\n}\n\nmodule.exports = Singleton;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/core/utils.js":"'use strict';\n\nconst util = require('util');\nconst is = require('is-type-of');\n\nmodule.exports = {\n  convertObject,\n};\n\nfunction convertObject(obj, ignore) {\n  if (!is.array(ignore)) ignore = [ ignore ];\n  for (const key of Object.keys(obj)) {\n    obj[key] = convertValue(key, obj[key], ignore);\n  }\n  return obj;\n}\n\nfunction convertValue(key, value, ignore) {\n  if (is.nullOrUndefined(value)) return value;\n\n  if (!ignore.includes(key)) {\n    if (is.symbol(value) || is.regExp(value)) return value.toString();\n    if (is.primitive(value)) return value;\n    if (is.array(value)) return value;\n  }\n\n  // only convert recursively when it's a plain object,\n  // o = {}\n  if (Object.getPrototypeOf(value) === Object.prototype) {\n    return convertObject(value, ignore);\n  }\n\n  // support class\n  const name = value.name || 'anonymous';\n  if (is.class(value)) {\n    return `<Class ${name}>`;\n  }\n\n  // support generator function\n  if (is.function(value)) {\n    return is.generatorFunction(value) ? `<GeneratorFunction ${name}>` : `<Function ${name}>`;\n  }\n\n  const typeName = value.constructor.name;\n  if (typeName) {\n    if (is.buffer(value) || is.string(value)) return `<${typeName} len: ${value.length}>`;\n    return `<${typeName}>`;\n  }\n\n  /* istanbul ignore next */\n  return util.format(value);\n}\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/loader/index.js":"'use strict';\n\nexports.EggLoader = require('egg-core').EggLoader;\nexports.AppWorkerLoader = require('./app_worker_loader');\nexports.AgentWorkerLoader = require('./agent_worker_loader');\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/loader/app_worker_loader.js":"'use strict';\n\nconst EggLoader = require('egg-core').EggLoader;\n\n/**\n * App Worker process Loader, will load plugins\n * @see https://github.com/eggjs/egg-loader\n */\nclass AppWorkerLoader extends EggLoader {\n\n  /**\n   * loadPlugin first, then loadConfig\n   * @since 1.0.0\n   */\n  loadConfig() {\n    super.loadPlugin();\n    super.loadConfig();\n  }\n\n  /**\n   * 开始加载所有约定目录\n   * @since 1.0.0\n   */\n  load() {\n    // app > plugin > core\n    this.loadApplicationExtend();\n    this.loadRequestExtend();\n    this.loadResponseExtend();\n    this.loadContextExtend();\n    this.loadHelperExtend();\n\n    // app > plugin\n    this.loadCustomApp();\n    // app > plugin\n    this.loadService();\n    // app > plugin > core\n    this.loadMiddleware();\n    // app\n    this.loadController();\n    // app\n    this.loadRouter(); // 依赖 controller\n  }\n\n}\n\nmodule.exports = AppWorkerLoader;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/loader/agent_worker_loader.js":"/**\n * AgentWorkerLoader 类，继承 BaseLoader，实现整个应用的加载机制\n */\n\n'use strict';\n\nconst EggLoader = require('egg-core').EggLoader;\n\n/**\n * Agent Worker 进程的 Loader，继承 egg-loader\n * @see https://github.com/eggjs/egg-loader\n */\nclass AgentWorkerLoader extends EggLoader {\n\n  /**\n   * loadPlugin first, then loadConfig\n   */\n  loadConfig() {\n    super.loadPlugin();\n    super.loadConfig();\n  }\n\n  load() {\n    this.loadAgentExtend();\n    this.loadCustomAgent();\n  }\n}\n\nmodule.exports = AgentWorkerLoader;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/lib/agent.js":"'use strict';\n\nconst path = require('path');\nconst EggApplication = require('./egg');\nconst AgentWorkerLoader = require('./loader').AgentWorkerLoader;\n\nconst EGG_LOADER = Symbol.for('egg#loader');\nconst EGG_PATH = Symbol.for('egg#eggPath');\n\n/**\n * Singleton instance in Agent Worker, extend {@link EggApplication}\n * @extends EggApplication\n */\nclass Agent extends EggApplication {\n  /**\n   * @constructor\n   * @param {Object} options - see {@link EggApplication}\n   */\n  constructor(options = {}) {\n    options.type = 'agent';\n    super(options);\n\n    this._wrapMessenger();\n\n    this.loader.load();\n\n    // dump config after loaded, ensure all the dynamic modifications will be recorded\n    this.dumpConfig();\n\n    // keep agent alive even it don't have any io tasks\n    setInterval(() => {}, 24 * 60 * 60 * 1000);\n\n    this._uncaughtExceptionHandler = this._uncaughtExceptionHandler.bind(this);\n    process.on('uncaughtException', this._uncaughtExceptionHandler);\n  }\n\n  _uncaughtExceptionHandler(err) {\n    if (!(err instanceof Error)) {\n      err = new Error(String(err));\n    }\n    /* istanbul ignore else */\n    if (err.name === 'Error') {\n      err.name = 'unhandledExceptionError';\n    }\n    this.coreLogger.error(err);\n  }\n\n  get [EGG_LOADER]() {\n    return AgentWorkerLoader;\n  }\n\n  get [EGG_PATH]() {\n    return path.join(__dirname, '..');\n  }\n\n  _wrapMessenger() {\n    for (const methodName of [ 'broadcast', 'sendTo', 'sendToApp', 'sendToAgent', 'sendRandom' ]) {\n      wrapMethod(methodName, this.messenger, this.coreLogger);\n    }\n\n    function wrapMethod(methodName, messenger, logger) {\n      const originMethod = messenger[methodName];\n      messenger[methodName] = function() {\n        const stack = new Error().stack.split('\\n').slice(1).join('\\n');\n        logger.warn('agent can\\'t call %s before server started\\n%s',\n          methodName, stack);\n        originMethod.apply(this, arguments);\n      };\n      messenger.once('egg-ready', () => {\n        messenger[methodName] = originMethod;\n      });\n    }\n  }\n\n  close() {\n    process.removeListener('uncaughtException', this._uncaughtExceptionHandler);\n    return super.close();\n  }\n\n}\n\nmodule.exports = Agent;\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/config/config.default.js":"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * The configuration of egg application, can be access by `app.config`\n * @class Config\n * @since 1.0.0\n */\n\nmodule.exports = appInfo => {\n\n  const config = {\n\n    /**\n     * The environment of egg\n     * @member {String} Config#env\n     * @see {appInfo#env}\n     * @since 1.0.0\n     */\n    env: appInfo.env,\n\n    /**\n     * The name of the application\n     * @member {String} Config#name\n     * @see {appInfo#name}\n     * @since 1.0.0\n     */\n    name: appInfo.name,\n\n    /**\n     * The key that signing cookies. It can contain multiple keys seperated by `,`.\n     * @member {String} Config#keys\n     * @see https://eggjs.org/zh-cn/basics/controller.html#cookie-秘钥\n     * @default\n     * @since 1.0.0\n     */\n    keys: '',\n\n    /**\n     * Whether application deployed after a reverse proxy,\n     * when true proxy header fields will be trusted\n     * @member {Boolean} Config#proxy\n     * @default\n     * @since 1.0.0\n     */\n    proxy: false,\n\n    /**\n     * Detect request's protocol from specified headers, not case-sensitive.\n     * Only worked when config.proxy set to true.\n     * @member {String} Config#protocolHeaders\n     * @default\n     * @since 1.0.0\n     */\n    protocolHeaders: 'x-forwarded-proto',\n\n    /**\n     * Detect request' ip from specified headers, not case-sensitive.\n     * Only worked when config.proxy set to true.\n     * @member {String} Config#ipHeaders\n     * @default\n     * @since 1.0.0\n     */\n    ipHeaders: 'x-forwarded-for',\n\n    /**\n     * Detect request' host from specified headers, not case-sensitive.\n     * Only worked when config.proxy set to true.\n     * @member {String} Config#hostHeaders\n     * @default\n     * @since 1.0.0\n     */\n    hostHeaders: 'x-forwarded-host',\n\n    /**\n     * package.json\n     * @member {Object} Config#pkg\n     * @see {appInfo#pkg}\n     * @since 1.0.0\n     */\n    pkg: appInfo.pkg,\n\n    /**\n     * The current directory of the application\n     * @member {String} Config#baseDir\n     * @see {appInfo#baseDir}\n     * @since 1.0.0\n     */\n    baseDir: appInfo.baseDir,\n\n    /**\n     * The current HOME directory\n     * @member {String} Config#HOME\n     * @see {appInfo#HOME}\n     * @since 1.0.0\n     */\n    HOME: appInfo.HOME,\n\n    /**\n     * The directory of server running. You can find `application_config.json` under it that is dumpped from `app.config`.\n     * @member {String} Config#rundir\n     * @default\n     * @since 1.0.0\n     */\n    rundir: path.join(appInfo.baseDir, 'run'),\n\n    /**\n     * dump config\n     *\n     * It will ignore special keys when dumpConfig\n     *\n     * @member Config#dump\n     * @property {Set} ignore - keys to ignore\n     */\n    dump: {\n      ignore: new Set([ 'pass', 'pwd', 'passd', 'passwd', 'password', 'keys', 'secret' ]),\n    },\n\n    /**\n     * configurations are confused to users\n     * {\n     *   [unexpectedKey]: [expectedKey],\n     * }\n     * @member Config#confusedConfigurations\n     * @type {Object}\n     */\n    confusedConfigurations: {\n      bodyparser: 'bodyParser',\n      notFound: 'notfound',\n      sitefile: 'siteFile',\n      middlewares: 'middleware',\n      httpClient: 'httpclient',\n    },\n  };\n\n  /**\n   * The option of `notfound` middleware\n   *\n   * It will return page or json depend on negotiation when 404,\n   * If pageUrl is set, it will redirect to the page.\n   *\n   * @member Config#notfound\n   * @property {String} pageUrl - the 404 page url\n   */\n  config.notfound = {\n    pageUrl: '',\n  };\n\n  /**\n   * The option of `siteFile` middleware\n   *\n   * You can map some files using this options, it will response immdiately when matching.\n   *\n   * @member {Object} Config#siteFile - key is path, and value is url or buffer.\n   * @example\n   * // 指定应用 favicon, => '/favicon.ico': 'https://eggjs.org/favicon.ico',\n   * config.siteFile = {\n   *   '/favicon.ico': 'https://eggjs.org/favicon.ico',\n   * };\n   */\n  config.siteFile = {\n    '/favicon.ico': fs.readFileSync(path.join(__dirname, 'favicon.png')),\n  };\n\n  /**\n   * The option of `bodyParser` middleware\n   *\n   * @member Config#bodyParser\n   * @property {Boolean} enable - enable bodyParser or not, default to true\n   * @property {String | RegExp | Function | Array} ignore - won't parse request body when url path hit ignore pattern, can not set `ignore` when `match` presented\n   * @property {String | RegExp | Function | Array} match - will parse request body only when url path hit match pattern\n   * @property {String} encoding - body 的编码格式，默认为 utf8\n   * @property {String} formLimit - form body 的大小限制，默认为 100kb\n   * @property {String} jsonLimit - json body 的大小限制，默认为 100kb\n   * @property {Boolean} strict - json body 解析是否为严格模式，如果为严格模式则只接受 object 和 array\n   * @property {Number} queryString.arrayLimit - 表单元素数组长度限制，默认 100，否则会转换为 json 格式\n   * @property {Number} queryString.depth - json 数值深度限制，默认 5\n   * @property {Number} queryString.parameterLimit - 参数个数限制，默认 1000\n   */\n  config.bodyParser = {\n    enable: true,\n    encoding: 'utf8',\n    formLimit: '100kb',\n    jsonLimit: '100kb',\n    strict: true,\n    // @see https://github.com/hapijs/qs/blob/master/lib/parse.js#L8 for more options\n    queryString: {\n      arrayLimit: 100,\n      depth: 5,\n      parameterLimit: 1000,\n    },\n  };\n\n  /**\n   * logger options\n   * @member Config#logger\n   * @property {String} dir - directory of log files\n   * @property {String} encoding - log file encloding, defaults to utf8\n   * @property {String} level - default log level, could be: DEBUG, INFO, WARN, ERROR or NONE, defaults to INFO in production\n   * @property {String} consoleLevel - log level of stdout, defaults to INFO in local serverEnv, defaults to WARN in unittest, defaults to NONE elsewise\n   * @property {Boolean} outputJSON - log as JSON or not, defaults to false\n   * @property {Boolean} buffer - if enabled, flush logs to disk at a certain frequency to improve performance, defaults to true\n   * @property {String} errorLogName - file name of errorLogger\n   * @property {String} coreLogName - file name of coreLogger\n   * @property {String} agentLogName - file name of agent worker log\n   * @property {Object} coreLogger - custom config of coreLogger\n   */\n  config.logger = {\n    dir: path.join(appInfo.root, 'logs', appInfo.name),\n    encoding: 'utf8',\n    env: appInfo.env,\n    level: 'INFO',\n    consoleLevel: 'INFO',\n    outputJSON: false,\n    buffer: true,\n    appLogName: `${appInfo.name}-web.log`,\n    coreLogName: 'egg-web.log',\n    agentLogName: 'egg-agent.log',\n    errorLogName: 'common-error.log',\n    coreLogger: {},\n  };\n\n  /**\n   * The option for httpclient\n   * @member Config#httpclient\n   * @property {Boolean} keepAlive - Enable http keepalive or not, default is true\n   * @property {Number} freeSocketKeepAliveTimeout - socket keepalive max free time, default is 4000 ms.\n   * @property {Number} timeout - socket max unative time, default is 30000 ms.\n   * @property {Number} maxSockets - max socket number of one host, default is Infinity.\n   * @property {Number} maxFreeSockets - max free socket number of one host, default is 256.\n   * @property {Boolean} enableDNSCache - Enable DNS lookup from local cache or not, default is false.\n   */\n  config.httpclient = {\n    keepAlive: true,\n    freeSocketKeepAliveTimeout: 4000,\n    timeout: 30000,\n    maxSockets: Infinity,\n    maxFreeSockets: 256,\n    enableDNSCache: false,\n  };\n\n  /**\n   * core enable middlewares\n   * @member {Array} Config#middleware\n   */\n  config.coreMiddleware = [\n    'meta',\n    'siteFile',\n    'notfound',\n    'bodyParser',\n  ];\n\n  /**\n   * emit `startTimeout` if worker don't ready after `workerStartTimeout` ms\n   * @member {Number} Config.workerStartTimeout\n   */\n  config.workerStartTimeout = 10 * 60 * 1000;\n\n  return config;\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/config/config.local.js":"'use strict';\n\nmodule.exports = {\n  logger: {\n    level: 'DEBUG',\n    consoleLevel: 'INFO',\n    coreLogger: {\n      consoleLevel: 'WARN',\n    },\n    buffer: false,\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/config/config.unittest.js":"'use strict';\n\nmodule.exports = {\n  logger: {\n    consoleLevel: 'WARN',\n    buffer: false,\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-egg/node_modules/egg/config/plugin.js":"'use strict';\n\nmodule.exports = {\n  // enable plugins\n\n  /**\n   * app global Error Handling\n   * @member {Object} Plugin#onerror\n   * @property {Boolean} enable - `true` by default\n   */\n  onerror: {\n    enable: true,\n    package: 'egg-onerror',\n  },\n\n  /**\n   * session\n   * @member {Object} Plugin#session\n   * @property {Boolean} enable - `true` by default\n   * @since 1.0.0\n   */\n  session: {\n    enable: true,\n    package: 'egg-session',\n  },\n\n  /**\n   * i18n\n   * @member {Object} Plugin#i18n\n   * @property {Boolean} enable - `true` by default\n   * @since 1.0.0\n   */\n  i18n: {\n    enable: true,\n    package: 'egg-i18n',\n  },\n\n  /**\n   * file and dir watcher\n   * @member {Object} Plugin#watcher\n   * @property {Boolean} enable - `true` by default\n   * @since 1.0.0\n   */\n  watcher: {\n    enable: true,\n    package: 'egg-watcher',\n  },\n\n  /**\n   * multipart\n   * @member {Object} Plugin#multipart\n   * @property {Boolean} enable - `true` by default\n   * @since 1.0.0\n   */\n  multipart: {\n    enable: true,\n    package: 'egg-multipart',\n  },\n\n  /**\n   * security middlewares and extends\n   * @member {Object} Plugin#security\n   * @property {Boolean} enable - `true` by default\n   * @since 1.0.0\n   */\n  security: {\n    enable: true,\n    package: 'egg-security',\n  },\n\n  /**\n   * local development helper\n   * @member {Object} Plugin#development\n   * @property {Boolean} enable - `true` by default\n   * @since 1.0.0\n   */\n  development: {\n    enable: true,\n    package: 'egg-development',\n  },\n\n  /**\n   * logger file rotater\n   * @member {Object} Plugin#logrotator\n   * @property {Boolean} enable - `true` by default\n   * @since 1.0.0\n   */\n  logrotator: {\n    enable: true,\n    package: 'egg-logrotator',\n  },\n\n  /**\n   * schedule tasks\n   * @member {Object} Plugin#schedule\n   * @property {Boolean} enable - `true` by default\n   * @since 2.7.0\n   */\n  schedule: {\n    enable: true,\n    package: 'egg-schedule',\n  },\n\n  /**\n   * `app/public` dir static serve\n   * @member {Object} Plugin#static\n   * @property {Boolean} enable - `true` by default\n   * @since 1.0.0\n   */\n  static: {\n    enable: true,\n    package: 'egg-static',\n  },\n\n  /**\n   * jsonp support for egg\n   * @member {Function} Plugin#jsonp\n   * @property {Boolean} enable - `true` by default\n   * @since 1.0.0\n   */\n  jsonp: {\n    enable: true,\n    package: 'egg-jsonp',\n  },\n\n  /**\n   * view plugin\n   * @member {Function} Plugin#view\n   * @property {Boolean} enable - `true` by default\n   * @since 1.0.0\n   */\n  view: {\n    enable: true,\n    package: 'egg-view',\n  },\n};\n"}